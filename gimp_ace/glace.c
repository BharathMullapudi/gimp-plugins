/* :PREAMBLE: Glace.c
 *
 * Wrapper-independent Code:
 *            For both PBMPLUS and Tk/Tcl-based versions
 */

/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.  See the file COPYING for details.
 *
 */

/* :HEADERS:
 */

#include <stdio.h>

#include <config.h> /* auto-generated by configure */
#include "glaceInt.h"

#include <math.h>
#include <float.h>  /* FLT_MIN ??? */
#include <string.h>
#include <stdlib.h>


#ifdef GLACE_GIMP
#include "color.h" /* for vR vG vB -> y conversion, below. */
#endif

/* :*** Process Blocks ***:

 * :FUNCTION: Glace_Output
 */
#define YMAP_ADD (1.0)
int
Glace_Output (
               Glace_WData wData,
           Glace_CfgInfo *cfgInfoPtr,
              Glace_ImgArrays *imgArraysPtr
)
{
  Glace_MidGray temp_gray, out_offset;
  int r, c;
  Glace_MidGray *agP;
  /*  register Glace_Pixel* opP;*/
  Glace_Gray *ogP, tmph, tmpl;

  /* COLOR_Yxy */
  Glace_Gray *xP, *yP;

  /* COLOR_LUMIN */
  Glace_Gray *rP, *gP, *bP;

  long temp_long;
  int round_off;
  register int gstep;
  
  /*float tmpz,tmpy;*/

  /* We output row-by-row */
  Glace_WPutImgStart(wData,cfgInfoPtr,imgArraysPtr);

  /* 255 because that brings zero to the right (?) place and
     1 because that becomes 0.5, that is rounding by truncation. */
  if ((GLACE_CFG(chrome)==GLACE_CC) || (GLACE_CFG(doubleout)==GLACE_TRUE))
    round_off=0;
  else
    round_off=1;

  if (GLACE_CFG(outputMethod) == GLACE_NORMAL)
    out_offset = (long)
      ldexp(255  + round_off,
            (ACC_BITS - OUT_BITS));
  /*   out_offset = (long)
      ldexp(255 - ((double) 255.0-2*GLACE_CFG(inoffsetVal))
                                 * GLACE_CFG(addbackFactor) + round_off,
				 (ACC_BITS - OUT_BITS));*/
  else
    out_offset = (255 + round_off) << (ACC_BITS - OUT_BITS);
  
  /*  tmpz= (float) ldexp((double)out_offset ,-(ACC_BITS - OUT_BITS + 1) );
  tmpy =  (float) ldexp((double)1.0 ,-(ACC_BITS - OUT_BITS + 1) );
  */



  agP = GLACE_IMG(outAccImgPtr);
  for (r = 0; r < GLACE_IMG(rows); r++)
    {
      Glace_WPutImgRowStart(wData, cfgInfoPtr, imgArraysPtr, r);

      if ((GLACE_CFG(chrome) != GLACE_CC)
	  && (GLACE_CFG(doubleout)==GLACE_FALSE))
	if (GLACE_CFG(doClip)==GLACE_FALSE)
	  for (  gstep = GLACE_IMG(pixelBytePad),
		   c = GLACE_IMG(cols), ogP = GLACE_IMG(putImgRowPtr);
		 c >0 ; c--, ogP++, ogP +=gstep, agP++)
	    {
	      temp_gray = (*agP + out_offset)
		>> (ACC_BITS - OUT_BITS + 1);
	      /*temp_gray = (Glace_MidGray) (((float) *agP)*tmpy +tmpz);*/
	      *ogP = temp_gray > 255 ? 255 : temp_gray < 0 ? 0 : temp_gray;
	    }
	else
	  for (  gstep = GLACE_IMG(pixelBytePad),
		   c = GLACE_IMG(cols), ogP = GLACE_IMG(putImgRowPtr);
		 c >0 ; c--, ogP++, ogP +=gstep, agP++)
	    {
	      temp_gray = (*agP + out_offset)
		>> (ACC_BITS - OUT_BITS + 1);
	      /*temp_gray = (Glace_MidGray) (((float) *agP)*tmpy +tmpz);*/
	      *ogP = temp_gray > 255 ? 255 : temp_gray < 0 ? 0 : 127;
	    }
      else if (GLACE_CFG(doubleout)==GLACE_TRUE)
	for (  gstep = 3+GLACE_IMG(pixelBytePad),
	     c = GLACE_IMG(cols),
		ogP = GLACE_IMG(putImgRowPtr);
		c >0 ;
	      c--, ogP+= gstep,++agP )
	  {
	    temp_long = (*agP + out_offset)
	      << (8-(ACC_BITS - OUT_BITS + 1));
	    temp_long = temp_long > 65535 ? 65535 : 
	      temp_long < 0 ? 0 : temp_long;
	    BYTE_SPLIT(temp_long, tmph, tmpl);
	    GLACE_ASSIGN(
			 *((Glace_Pixel *)ogP),
			 tmph,tmph,tmpl);
	}
      else if (GLACE_CFG(colorMethod)==GLACE_COLOR_Yxy) {
	for ( gstep = 3+GLACE_IMG(pixelBytePad),
	     c = GLACE_IMG(cols),
		ogP = GLACE_IMG(putImgRowPtr),
		xP = GLACE_IMG(inImgCxPtr)
		+ r * GLACE_IMG(cols) * GLACE_IMG(pixelSize),
		yP = GLACE_IMG(inImgCyPtr)
		+ r * GLACE_IMG(cols) * GLACE_IMG(pixelSize);
	      c >0 ;
	      c--, ogP+=gstep,
		xP+=GLACE_IMG(pixelSize),
		yP+=GLACE_IMG(pixelSize), ++agP )
	  
	{
	  float x, y, X2, Y2, Z2, vR, vG, vB;
	  /* Note that x and y here range from 0 - 255 */
	  x = *xP;
	  y = *yP;

	  Y2 =  (float) 
	    ldexp((double)*agP + out_offset ,-(ACC_BITS - OUT_BITS + 1) );
	  Y2 = CLAMP(Y2,0,255);

	  /* Convert new XYZ coordinates to RGB. */
	  /* This is what it looks like without Y2 factored out:
	     vR = CLAMP(R_x * X2 + R_y * Y2 + R_z * Z2, 0,255); */

	  /* Make new XYZ coordinates with new Y and same chromacity. */
	  /* NOTE: These are not really X and Z coordinates!
	     They are missing a factor of Y2.
	     (Notice that Y2 is a factor of every term in the RGB
	     equations, so one may factor it out...) */
	  X2 = (x / y); /* * Y2 */
	  Z2 = ((255.0 - x - y) / y); /* * Y2 */

	  vR = CLAMP(Y2 * (R_x * X2 + R_y + R_z * Z2), 0,255);
	  vG = CLAMP(Y2 * (G_x * X2 + G_y + G_z * Z2), 0,255);
	  vB = CLAMP(Y2 * (B_x * X2 + B_y + B_z * Z2), 0,255);

	  GLACE_ASSIGN(
		  *((Glace_Pixel *)ogP),
		  vR, vG, vB);
	}
      } /* endif COLOR_Yxy */
      else { /* COLOR_LUMIN */
	for ( gstep = 3+GLACE_IMG(pixelBytePad),
	     c = GLACE_IMG(cols),
		ogP = GLACE_IMG(putImgRowPtr),
		rP = GLACE_IMG(inImgRPtr)
		+ r * GLACE_IMG(cols) * GLACE_IMG(pixelSize),
		gP = GLACE_IMG(inImgGPtr)
		+ r * GLACE_IMG(cols) * GLACE_IMG(pixelSize),
		bP = GLACE_IMG(inImgBPtr)
		+ r * GLACE_IMG(cols) * GLACE_IMG(pixelSize);
	      c >0 ;
	      c--, ogP+=gstep,
		rP+=GLACE_IMG(pixelSize),
		gP+=GLACE_IMG(pixelSize), bP+=GLACE_IMG(pixelSize), ++agP )
	  
	{
          float y1, y2, vR, vG, vB, lambda;
	  float alpha, beta;
	  const Glace_Gray mmaxval = GLACE_MAXMAXGRAY;

	  y2 =  (float) 
	    ldexp((double)*agP + out_offset ,-(ACC_BITS - OUT_BITS + 1) );
	  y2 = y2 > 255 ? 255 : y2 < 0 ? 0 : y2;

	  vR = *rP;
	  vG = *gP;
	  vB = *bP;


	  /* y1 = 0.299*vR + 0.587*vG + 0.114*vB; */
	  y1 = Y_r * vR + Y_g * vG + Y_b * vB;
	  
	  vR -= y1;
	  vG -= y1;
	  vB -= y1;
	  beta = max(max(vR, vG), vB);
	  alpha = abs(min(min(vR, vG), vB));
	  
	  /*	  lambda = min( beta*(y1-1), alpha*(maxval-1-y1) )/(beta+0.001)/(alpha+0.001);*/
		  
	  lambda = min( beta*y2, alpha*(mmaxval-y2) ) /
		  (YMAP_ADD+min( beta*y1, alpha*(mmaxval-y1) ) );
	  
	  /*	  lambda = min( y2/alpha, (maxval-y2)/beta ) /
		  (YMAP_ADD+min( y1/alpha, (maxval-y1)/beta ) );*/
	  
	  GLACE_ASSIGN(
		  *((Glace_Pixel *)ogP),
		  y2 + lambda* vR,
		  y2 + lambda* vG,
		  y2 + lambda* vB);
	} /* next ogP */
      } /* endif COLOR_LUMIN */
	
	Glace_WPutImgRowFinish(wData, cfgInfoPtr, imgArraysPtr, r);
    }
  
  Glace_WPutImgFinish(wData, cfgInfoPtr, imgArraysPtr);
  
  return Glace_WErrorValue( GLACE_IMG(wData) );
}



/**************************************************************/
/*
 * :FUNCTION: GlaceBigGrayAccumulate
 */
void
GlaceBigGrayAccumulate(
               Glace_CfgInfo *cfgInfoPtr,
              Glace_TableInfo *tableInfoPtr,
              Glace_ImgArrays *imgArraysPtr
)
{
  register long  r;
  register Glace_MidGray *agP;
  register Glace_Gray *hgP, *lgP;
  register Glace_BigGray *bgP;
  register long tmplong, tmpoffset;

#if 0
  register Glace_Gray pixA, pixB;

  Glace_FillTableForNotFilt (cfgInfoPtr,tableInfoPtr);

  tmpoffset = 1 <<(GLACE_TRM(accShift)-1);

  for (r = GLACE_IMG(rows)*GLACE_IMG(cols)-2,
         bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
         agP = (GLACE_IMG(accImgPtr)),
         hgP = (GLACE_IMG(inImgHBPtr))+1, pixA = *(GLACE_IMG(inImgHBPtr)),
         pixB=*((GLACE_IMG(inImgHBPtr))+1); r !=0; r--)
              {
                tmplong = GLACE_TRM(seriesTable)[pixA];
                tmplong *= (*bgP >> (BSHIFT));
                tmplong += tmpoffset;

                *agP += (Glace_MidGray) (tmplong >> GLACE_TRM(accShift) );

                pixA = pixB;
                pixB = *hgP;
                bgP++; agP++; hgP++;
              }
                tmplong = GLACE_TRM(seriesTable)[pixA];
                tmplong *= (*bgP >> (BSHIFT));
                tmplong += tmpoffset;

                *agP += (Glace_MidGray) (tmplong >> GLACE_TRM(accShift) );

#elif 0

  register Glace_Gray pixA;

  register int thisShift;
  Glace_FillTableForNotFilt (cfgInfoPtr,tableInfoPtr);

  thisShift = GLACE_TRM(accShift);

  tmpoffset = 1 <<(GLACE_TRM(accShift)-1);

  /* About 1% better! */
  for (r = GLACE_IMG(rows)*GLACE_IMG(cols)-1,
         bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
         agP = (GLACE_IMG(accImgPtr)),
         hgP = (GLACE_IMG(inImgHBPtr))+1, pixA = *(GLACE_IMG(inImgHBPtr));
       r !=0; r--)
              {
                tmplong = GLACE_TRM(seriesTable)[pixA];
                tmplong *= (*bgP >> (BSHIFT));
                tmplong += tmpoffset;

                *agP += (Glace_MidGray) (tmplong >> (thisShift) );
                pixA = *hgP;

                bgP++; agP++; hgP++;
              }
                tmplong = GLACE_TRM(seriesTable)[pixA];
                tmplong *= (*bgP >> (BSHIFT));
                tmplong += tmpoffset;

                *agP += (Glace_MidGray) (tmplong >> (thisShift) );
#elif 0

  Glace_FillTableForNotFilt (cfgInfoPtr,tableInfoPtr);

  tmpoffset = 1 <<(GLACE_TRM(accShift)-1);

  Glace_MidGray *cgP, tmpMG, tmpMGZ;
  for (r = GLACE_IMG(rows)*GLACE_IMG(cols)-1,
         bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
         agP = (GLACE_IMG(accImgPtr)), cgP = (GLACE_IMG(accImgPtr))+1,
         hgP = (GLACE_IMG(inImgHBPtr)), pixA = *(GLACE_IMG(inImgHBPtr));
       r !=0; r--)
              {

                *agP = tmpMGZ;

                tmplong = GLACE_TRM(seriesTable)[pixA];
                tmplong *= (*bgP >> (BSHIFT));
                tmplong += tmpoffset;
                tmpMG = (Glace_MidGray) (tmplong >> GLACE_TRM(accShift) );
                tmpMGZ = *cgP + tmpMG;

                pixA = *hgP;
                bgP++; agP++; hgP++; cgP++;
              }




#elif 0

  float tmpa, tmpb, tmpc, tmplookup[256];

  Glace_FillTableForNotFilt (cfgInfoPtr,tableInfoPtr);

  tmpb = (float) (1 >> (BSHIFT + GLACE_TRM(accShift) ));
  tmpc = (float) 0.5;

  for (r=255, r>=0, r--)
    tmplookup[r] = (float) GLACE_TRM(seriesTable)[r] * tmpb;

  for (r = GLACE_IMG(rows)*GLACE_IMG(cols),
         bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
         agP = (GLACE_IMG(accImgPtr)),
         hgP = (GLACE_IMG(inImgHBPtr)); r !=0; r--)
              {
                tmpa = tmplookup[*hgP];
                tmpa *= (float) *bgP;
                tmpa += tmpc;

                *agP += (Glace_MidGray) (tmpa);
                /*
                 *agP += (Glace_MidGray)
                 (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA);
                 */

                bgP++; agP++; hgP++;
              }

#elif 0

  Glace_FillTableForNotFilt (cfgInfoPtr,tableInfoPtr);

  tmpoffset = 1 <<(GLACE_TRM(accShift)-1);

  for (r = GLACE_IMG(rows)*GLACE_IMG(cols),
         bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
         agP = (GLACE_IMG(accImgPtr)),
         hgP = (GLACE_IMG(inImgHBPtr)); r !=0; r--)
              {
                tmplong = GLACE_TRM(seriesTable)[*hgP];
                tmplong *= (*bgP >> (BSHIFT));
                tmplong += tmpoffset;

                *agP += (Glace_MidGray) (tmplong >> GLACE_TRM(accShift) );
                /*
                 *agP += (Glace_MidGray)
                 (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA);
                 */

                bgP++; agP++; hgP++;
              }
#else
  register int thisShift;
  register long* thisTable;
  register Glace_FpSeries *thisAH, *thisAL, *thisBH, *thisBL;
  register float thisABF;
  Glace_FillTableForNotFilt (cfgInfoPtr,tableInfoPtr);

  thisShift = GLACE_TRM(accShift);
  tmpoffset = 1 <<(GLACE_TRM(accShift)-1);


  if (GLACE_CFG(doublep)==GLACE_FALSE)
    {
  thisTable = GLACE_TRM(seriesTable);
    for (r = GLACE_IMG(rows)*GLACE_IMG(cols),
	   bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
	   agP = (GLACE_IMG(accImgPtr)),
	   hgP = (GLACE_IMG(inImgHBPtr)); r !=0; r--)
      {
	tmplong = thisTable[*hgP];
	tmplong *= (*bgP >> (BSHIFT));
	tmplong += tmpoffset;
	
	*agP += (Glace_MidGray) (tmplong >> thisShift );
	/*
	 *agP += (Glace_MidGray)
	 (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA);
	*/
	
	bgP++; agP++; hgP++;
      }
    }
  else
    {
      thisABF = GLACE_TRM(abFactor);
      thisAH = GLACE_TRM(seriesAH);
      thisAL = GLACE_TRM(seriesAL);
      thisBH = GLACE_TRM(seriesBH);
      thisBL = GLACE_TRM(seriesBL);
      if (GLACE_TRM(termType) == GLACE_COS)
	for (r = GLACE_IMG(rows)*GLACE_IMG(cols),
	       bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
	       agP = (GLACE_IMG(accImgPtr)),
	       hgP = (GLACE_IMG(inImgHBPtr)),
	       lgP = (GLACE_IMG(inImgLBPtr)); r !=0; r--)
	  {
#if 1
	    tmplong = thisAH[*hgP]*thisBL[*lgP] -
	      thisBH[*hgP]*thisAL[*lgP] + 0.5;
	    tmplong *= (*bgP >> (BSHIFT));
#else
	    tmplong = (thisAH[*hgP]*thisBL[*lgP] -
	      thisBH[*hgP]*thisAL[*lgP])
	      * ldexp(*bgP,- (BSHIFT));
#endif
	    tmplong += tmpoffset;
	    
	    *agP += (Glace_MidGray) (tmplong >> thisShift );
	    /*
	     *agP += (Glace_MidGray)
	     (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA);
	    */
	    
	    bgP++; agP++; hgP++, lgP++;
	  }
      else
	for (r = GLACE_IMG(rows)*GLACE_IMG(cols),
	       bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
	       agP = (GLACE_IMG(accImgPtr)),
	       hgP = (GLACE_IMG(inImgHBPtr)),
	       lgP = (GLACE_IMG(inImgLBPtr)); r !=0; r--)
	  {
#if 1
	    tmplong = thisAH[*hgP]*thisBL[*lgP] -
	      thisBH[*hgP]*thisAL[*lgP] + 0.5     +thisABF;
	    tmplong *= (*bgP >> (BSHIFT));
#else
	    tmplong = (thisAH[*hgP]*thisBL[*lgP] -
	      thisBH[*hgP]*thisAL[*lgP])
	      * ldexp(*bgP,- (BSHIFT));
#endif
	    tmplong += tmpoffset;
	    
	    *agP += (Glace_MidGray) (tmplong >> thisShift );
	    /*
	     *agP += (Glace_MidGray)
	     (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA);
	    */
	    
	    bgP++; agP++; hgP++, lgP++;
	  }
    }
    
#endif
}


/**************************************************************/
/*
 * :FUNCTION: GlaceMidGrayAccumulate
 */
void
GlaceMidGrayAccumulate(
               Glace_CfgInfo *cfgInfoPtr,
              Glace_TableInfo *tableInfoPtr,
              Glace_ImgArrays *imgArraysPtr
)
{
  long  r;
  register Glace_MidGray *agP;
  register Glace_Gray *igP;
  register Glace_MidGray *mgP;
  register long tmplong, tmpoffset;

  Glace_FillTableForNotFilt (cfgInfoPtr,tableInfoPtr);

  tmpoffset = 1 <<(GLACE_TRM(accShift)-1);

  for (r = GLACE_IMG(rows)*GLACE_IMG(cols),
         mgP = (Glace_MidGray *) GLACE_IMG(tmpImgPtr),
         agP = (GLACE_IMG(accImgPtr)),
         igP = (GLACE_IMG(inImgHBPtr)); r !=0; r--)
              {
                tmplong = GLACE_TRM(seriesTable)[*igP];
                tmplong *= (*mgP >> (MSHIFT));
                tmplong += tmpoffset;

                *agP += (Glace_MidGray) (tmplong >> GLACE_TRM(accShift) );

                mgP++; agP++; igP++;
              }
}

/**************************************************************/
/*
 * :FUNCTION: Glace_CallFilt
 */
void 
Glace_CallFilt (
               Glace_CfgInfo *cfgInfoPtr,
                 Glace_TableInfo *tableInfoPtr,
             Glace_ImgArrays *imgArraysPtr)
{

  if (GLACE_CFG(filtMethod) == GLACE_WINDOW)
    if (GLACE_TRM(termType == GLACE_COS))
      Glace_FiltWind (cfgInfoPtr,
		      GLACE_IMG(refImgHBPtr),
		      GLACE_IMG(refImgLBPtr),
                      (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
                      /*GLACE_TRM(filtTable),*/
                      GLACE_IMG(cols), GLACE_IMG(rows), tableInfoPtr,
                      GLACE_CFG(windCWSeries[GLACE_TRM(termNum)]),
                      GLACE_CFG(windCHSeries[GLACE_TRM(termNum)]));
    else
      Glace_FiltWind (cfgInfoPtr,
		      GLACE_IMG(refImgHBPtr),
		      GLACE_IMG(refImgLBPtr),
                      (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
                      /*GLACE_TRM(filtTable),*/
                      GLACE_IMG(cols), GLACE_IMG(rows), tableInfoPtr,
                      GLACE_CFG(windSWSeries[GLACE_TRM(termNum)]),
                      GLACE_CFG(windSHSeries[GLACE_TRM(termNum)]));
  else if (GLACE_CFG(filtMethod) == GLACE_DIRDIFF)
    {
      if (GLACE_TRM(termType == GLACE_COS))
	Glace_FiltDD (cfgInfoPtr,
		      GLACE_IMG(refImgHBPtr),
		      (Glace_MidGray *) GLACE_IMG(tmpImgPtr),
		      /*GLACE_TRM(filtTable),*/
		      GLACE_IMG(cols), GLACE_IMG(rows), tableInfoPtr,
		      GLACE_IMG(ddHImgPtr), GLACE_IMG(ddVImgPtr),
		      GLACE_CFG(GLACE_CFG_COSDIM[GLACE_TRM(termNum)]));
      else
	Glace_FiltDD (cfgInfoPtr,
		      GLACE_IMG(refImgHBPtr),
		      (Glace_MidGray *) GLACE_IMG(tmpImgPtr),
		      /*GLACE_TRM(filtTable),*/
		      GLACE_IMG(cols), GLACE_IMG(rows), tableInfoPtr,
		      GLACE_IMG(ddHImgPtr), GLACE_IMG(ddVImgPtr),
		      GLACE_CFG(GLACE_CFG_SINDIM[GLACE_TRM(termNum)]));
    }
  GLACE_ERROR_CHECK( GLACE_CFG(wData) );
}


/**************************************************************/
/*
 * :FUNCTION: Glace_InitAccIm
 */
void 
Glace_InitAccIm (
               Glace_CfgInfo *cfgInfoPtr,
             Glace_ImgArrays *imgArraysPtr)
{
  Glace_MidGray start_offset;
  long r;
  Glace_MidGray *agP;
  Glace_Gray *hgP, *lgP;
  float ptfac;

  if (GLACE_CFG(outputMethod) != GLACE_NORMAL)
    return;
  
  start_offset = (long)
    ldexp( - ((double) 255.0-2*GLACE_CFG(inoffsetVal))
	   * (GLACE_CFG(addbackFactor))
	   - 255.0*GLACE_CFG(passthruFactor),
	   (ACC_BITS - OUT_BITS));
  
  ptfac =  ldexp((double) 2*GLACE_CFG(passthruFactor),
		 (ACC_BITS - OUT_BITS-8));
  
  if (GLACE_CFG(doublep) == GLACE_TRUE )
    for (r = GLACE_IMG(rows)*GLACE_IMG(cols),
	   agP = (GLACE_IMG(accImgPtr)),
	   hgP = (GLACE_IMG(inImgHBPtr)),
	   lgP = (GLACE_IMG(inImgLBPtr)); r !=0; r--)
      {
	*agP += start_offset + ptfac*(*hgP*256+*lgP);
	agP++; lgP++; hgP++;
      }
  else
    for (r = GLACE_IMG(rows)*GLACE_IMG(cols),
	   agP = (GLACE_IMG(accImgPtr)),
	   hgP = (GLACE_IMG(inImgHBPtr)); r !=0; r--)
      {
	*agP += start_offset + ptfac*(*hgP*256);
	agP++; lgP++; hgP++;
      }  
}


/**************************************************************/
/*
 * :FUNCTION: Glace_GenGen
 */
void 
Glace_GenGen (
               Glace_CfgInfo *cfgInfoPtr,
                 Glace_TableInfo *tableInfoPtr,
             Glace_ImgArrays *imgArraysPtr)
{

  if ((GLACE_TRM(accShift)<MAX_BIT_SHIFT) &&
      /*( (abs(GLACE_CFG(heseriesSeries)[GLACE_TRM(termNum)])
	 > GLACE_CFG(coeffTol))
	|| (abs(GLACE_CFG(addbackSeries)[GLACE_TRM(termNum)])
	> GLACE_CFG(coeffTol)) )*/
      GLACE_TRM(termNum) <= GLACE_CFG(activeTerms)
      )
      {
        Glace_CallFilt ( cfgInfoPtr, tableInfoPtr, imgArraysPtr);
        GLACE_ERROR_CHECK( GLACE_CFG(wData) );

        if (GLACE_IMG(tmpImgGraySize) == sizeof(Glace_BigGray))
          GlaceBigGrayAccumulate(cfgInfoPtr, tableInfoPtr,imgArraysPtr);
        else if (GLACE_CFG(filtMethod) == GLACE_DIRDIFF)
          GlaceMidGrayAccumulate(cfgInfoPtr, tableInfoPtr,imgArraysPtr);
      }
}




/**************************************************************/

/* :*** Image Array Allocation ***:

 * :FUNCTION: Glace_SetTmpImg
 */
void
Glace_SetTmpImg (
                 Glace_ImgArrays *imgArraysPtr,
                 size_t graySize,
                 int rowPad,
                 int colPad
                 )
{
  GLACE_IMG(tmpImgGraySize) = graySize;
  GLACE_IMG(tmpImgRPad) = rowPad;
  GLACE_IMG(tmpImgCPad) = colPad;
}

/**************************************************************/
/*
 * :FUNCTION: Glace_DefaultTmpImg
 */
void
Glace_DefaultTmpImg (
                 Glace_CfgInfo *cfgInfoPtr,
             Glace_ImgArrays *imgArraysPtr
                 )
{
  if ((GLACE_CFG(outputMethod) == GLACE_SINRAW) ||
      (GLACE_CFG(outputMethod) == GLACE_COSRAW) ||
      (GLACE_CFG(filtMethod) == GLACE_DIRDIFF))
    Glace_SetTmpImg(imgArraysPtr, sizeof (Glace_MidGray), 1, 0);
  else
    Glace_SetTmpImg(imgArraysPtr, sizeof (Glace_BigGray), 1, 1);
}

/**************************************************************/
/*
 * :FUNCTION: Glace_AllocImgArrays
 */
void
Glace_AllocImgArrays (
                 Glace_CfgInfo *cfgInfoPtr,
             Glace_ImgArrays *imgArraysPtr
                 )
{
  long newTmpImgSize;
  char *tmpPtr;
  float minBound;
  
  if ((GLACE_CFG(outputMethod) == GLACE_NORMAL) &&
      (GLACE_CFG(plainGlace) == GLACE_TRUE))
    {
      GLACE_IMG(accImgPtr) = (Glace_MidGray *)
        Glace_CallocReallocFree( GLACE_IMG(accImgPtr), &GLACE_IMG(accImgSize),
                                 GLACE_IMG(cols) * GLACE_IMG(rows),
                                 sizeof (Glace_MidGray), 0.9);
      memset (GLACE_IMG(accImgPtr), '\0',
              GLACE_IMG(cols) * GLACE_IMG(rows) * sizeof (Glace_MidGray));
    }

  /* Get the old pointer in case we need to reassign or free */
  tmpPtr = GLACE_IMG(tmpImgPtr);
  

  newTmpImgSize = (GLACE_IMG(cols) + GLACE_IMG(tmpImgCPad)) *
    (GLACE_IMG(rows) + GLACE_IMG(tmpImgRPad)) *
    GLACE_IMG(tmpImgGraySize);
    
  /* We allow a certain slack if the new image is slightly smaller
   * than the old one.  Also, we allow greater shrinkage if the image
   * is diagnostic, since the user will probably go back to the larger
   * one later anyway.  Hence a base gray size of 4 bytes is assumed.
   */
  if (GLACE_IMG(tmpImgGraySize) < sizeof(Glace_BigGray))
    minBound = 0.9 *
      ((float) GLACE_IMG(tmpImgGraySize)) / sizeof(Glace_BigGray);
  else
    minBound = 0.9;

  tmpPtr = (char *) 
    Glace_CallocReallocFree( tmpPtr, &GLACE_IMG(tmpImgSize), newTmpImgSize,
                             1, minBound);
  
  
/*       (Glace_BigGray *) GLACE_IMG(tmpImgPtr) = (Glace_BigGray *) tmpPtr; */
/*       (Glace_MidGray *) GLACE_IMG(tmpImgPtr) = (Glace_MidGray *) tmpPtr; */
  /*
    if (GLACE_IMG(tmpImgGraySize) == GLACE_TMP_IMG_BIG)
    {
    (Glace_BigGray *) GLACE_IMG(tmpImgPtr) = (Glace_BigGray *) tmpPtr;
    (Glace_MidGray *) GLACE_IMG(tmpImgPtr) = NULL;
    }
    else
    {
    (Glace_MidGray *) GLACE_IMG(tmpImgPtr) = (Glace_MidGray *) tmpPtr;
    (Glace_BigGray *) GLACE_IMG(tmpImgPtr) = NULL;
    }
    */
  GLACE_IMG(tmpImgPtr) = tmpPtr;

  /* Assign the pointer to the accumulator used for output */
  if (GLACE_CFG(outputMethod) == GLACE_NORMAL)
    GLACE_IMG(outAccImgPtr) = GLACE_IMG(accImgPtr);
  else
    GLACE_IMG(outAccImgPtr) = (Glace_MidGray *) tmpPtr; 
  
}

/**************************************************************/
/*
 * :FUNCTION: Glace_FreeImgArrays
 */
void
Glace_FreeImgArrays (
                 Glace_CfgInfo *cfgInfoPtr,
             Glace_ImgArrays *imgArraysPtr
                 )
{
  if (GLACE_CFG(outputMethod) == GLACE_NORMAL)
    Glace_CallocReallocFree( GLACE_IMG(accImgPtr), &GLACE_IMG(accImgSize),
                             0,
                             sizeof (Glace_MidGray), 0.9);

  Glace_CallocReallocFree( GLACE_IMG(tmpImgPtr),
                           &GLACE_IMG(tmpImgSize), 0, 1, 0.9);
  
  
}

/**************************************************************/
/*
 * :FUNCTION: Glace_AllocInputImgArrays
 */
void
Glace_AllocInputImgArrays (
                 Glace_CfgInfo *cfgInfoPtr,
             Glace_ImgArrays *imgArraysPtr
             )
{
  int bytesper;

  if (GLACE_CFG(doublep)==GLACE_FALSE)
    bytesper = 1;
  else
    bytesper = 2;

  if (GLACE_CFG(refimageMode) == GLACE_SEPARATE)
    GLACE_IMG(refImgPtr) = (Glace_Gray *) 
      Glace_CallocReallocFree( GLACE_IMG(refImgPtr), &GLACE_IMG(refImgSize),
                               GLACE_IMG(rows)*GLACE_IMG(cols)*bytesper,
                               sizeof(Glace_Gray), 0.9);
  else
    GLACE_IMG(refImgPtr) = (Glace_Gray *) 
      Glace_CallocReallocFree( GLACE_IMG(refImgPtr), &GLACE_IMG(refImgSize),
                               0,
                               sizeof(Glace_Gray), 0.9);
  GLACE_IMG(inImgPtr) = (Glace_Gray *) 
    Glace_CallocReallocFree( GLACE_IMG(inImgPtr), &GLACE_IMG(inImgSize),
                             GLACE_IMG(rows)*GLACE_IMG(cols)*bytesper,
                             sizeof(Glace_Gray), 0.9);
}


/**************************************************************/
/*
 * :FUNCTION: Glace_FreeInputImgArrays
 */
void
Glace_FreeInputImgArrays (
             Glace_ImgArrays *imgArraysPtr
                 )
{
  if (GLACE_IMG(refImgHBPtr) != GLACE_IMG(inImgHBPtr))
    GLACE_IMG(refImgHBPtr) = (Glace_Gray *) 
    Glace_CallocReallocFree( GLACE_IMG(refImgHBPtr), &GLACE_IMG(refImgSize),
                             0,
                             sizeof(Glace_Gray), 0.9);
  GLACE_IMG(inImgHBPtr) = (Glace_Gray *) 
    Glace_CallocReallocFree( GLACE_IMG(inImgHBPtr), &GLACE_IMG(inImgSize),
                             0,
                             sizeof(Glace_Gray), 0.9);

}


/**************************************************************/

/**************************************************************/

/* :*** General Memory Allocation ***:

 * :FUNCTION: Glace_AllocClientData
 */
Glace_ClientData *
Glace_AllocClientData ()
{
  Glace_ClientData *clientData;

  clientData = (Glace_ClientData *) GlaceWMalloc(sizeof(Glace_ClientData));
  
  GLACE_CDATA(wData)        = Glace_WDataAlloc();
  GLACE_CDATA(cfgInfoPtr)   = (Glace_CfgInfo *) 
    GlaceWMalloc(sizeof(Glace_CfgInfo));
  GLACE_CDATA(tableInfoPtr) = (Glace_TableInfo *)
    GlaceWMalloc(sizeof(Glace_TableInfo));
  GLACE_CDATA(imgArraysPtr) = (Glace_ImgArrays *)
    GlaceWMalloc(sizeof(Glace_ImgArrays));

   memset(GLACE_CDATA(cfgInfoPtr), '\0',sizeof(Glace_CfgInfo));
   memset(GLACE_CDATA(tableInfoPtr), '\0',sizeof(Glace_TableInfo));
   memset(GLACE_CDATA(imgArraysPtr), '\0',sizeof(Glace_ImgArrays));

   (GLACE_CDATA(cfgInfoPtr))->wData = 
     (GLACE_CDATA(tableInfoPtr))->wData = 
     (GLACE_CDATA(imgArraysPtr))->wData = GLACE_CDATA(wData);

   return clientData;
}

/**************************************************************/
/*
 * :FUNCTION: Glace_FreeClientData
 */
void
Glace_FreeClientData (
                       Glace_ClientData *clientData
                       )
{
  GlaceWFree(GLACE_CDATA(wData));
  GlaceWFree(GLACE_CDATA(cfgInfoPtr));
  GlaceWFree(GLACE_CDATA(tableInfoPtr));
  GlaceWFree(GLACE_CDATA(imgArraysPtr));
  GlaceWFree(clientData);
}


/**************************************************************/
/*
 * :FUNCTION: Glace_CallocReallocFree
 */
char *
Glace_CallocReallocFree(
                        void *p,
                        long *nObjPtr,
                        long newNObj,
                        size_t size,
                        float minBound
)
{  
  char *tmpPtr=NULL;

  if ( ((newNObj*((long) size))>*nObjPtr )
       || ((newNObj*size)<(*nObjPtr*minBound))
       || ((newNObj*size)==0) )
    {
      if (*nObjPtr != 0)
        if ((newNObj*size)==0)
          GlaceWFree(p);
        else {
        /*          tmpPtr = (char *) GlaceWRealloc (p, newNObj*size);*/
         GlaceWFree(p);
          tmpPtr = (char *) GlaceWMalloc (newNObj*size);
        }
      else
        if ((newNObj*size)!=0)
          tmpPtr = (char *) GlaceWMalloc (newNObj*size);
      
      *nObjPtr = (newNObj*size);
    }
  else
    tmpPtr = (char *) p;

  return tmpPtr;
} 


/**************************************************************/

/* :*** Lookup Table and Term-Wise Stuff ***:

 * :FUNCTION: Glace_AllocTables
 */
void
Glace_AllocTables (
                 GLACE_OVAR(Glace_CfgInfo *cfgInfoPtr),
                 Glace_TableInfo *tableInfoPtr
                 )
{
  if (GLACE_CFG(doublep)==GLACE_FALSE)
    {
      if (GLACE_TRM(seriesTable) == NULL)
	GLACE_TRM(seriesTable) =
	  (long * ) GlaceWCalloc(GLACE_MAXMAXGRAY + 1 , sizeof( long ) );
    }
  else if (GLACE_TRM(seriesAH) == NULL)
    {
      GLACE_TRM(seriesAH) =
	(Glace_FpSeries *) GlaceWCalloc( (GLACE_MAXMAXGRAY +1)*4 ,
				sizeof( Glace_FpSeries ) );
      GLACE_TRM(seriesAL) = GLACE_TRM(seriesAH) +GLACE_MAXMAXGRAY + 1;
      GLACE_TRM(seriesBH) = GLACE_TRM(seriesAL) +GLACE_MAXMAXGRAY + 1;
      GLACE_TRM(seriesBL) = GLACE_TRM(seriesBH) +GLACE_MAXMAXGRAY + 1;
    }
}

/**************************************************************/
/*
 * :FUNCTION: Glace_FreeTables
 */
void
Glace_FreeTables (
                 GLACE_OVAR(Glace_CfgInfo *cfgInfoPtr),
                 Glace_TableInfo *tableInfoPtr
                 )
{
  GlaceWFree(GLACE_TRM(seriesTable));
  GlaceWFree(GLACE_TRM(seriesAH));
}

/*
 * :FUNCTION: Glace_SetForTerm
 */
void
Glace_SetForTerm (
                 Glace_TableInfo *tableInfoPtr,
                 int k,
                 Glace_TermTypes type
                 )
{
  GLACE_TRM(termNum) = k;
  GLACE_TRM(termType) = type;
}

/**************************************************************/
/*
 * :FUNCTION: Glace_SetTables
 */
void 
Glace_SetTables (
                  Glace_CfgInfo *cfgInfoPtr,
                  Glace_TableInfo *tableInfoPtr
)
{
  float area;
  int filtShifts, notFiltShifts, abShifts;
  float filtFactor, notFiltFactor, abFactor;
  /*  int r;*/

  double waveFactor;

  /* Set the table tableInfoPtr so that, after filtering (or without
   * filtering) the resulting field will have max magnitude
   * AFTFILTVAL.  If DIRDIFF is used, this will be shifted down to
   * sit in a two-byte integer instead.
   *
   * The filter must shift the values down by filtShifts as part
   * of its processing.  */
  if ((GLACE_CFG(outputMethod) == GLACE_SINRAW) ||
      (GLACE_CFG(outputMethod) == GLACE_COSRAW) ||
      (GLACE_CFG(filtMethod) == GLACE_DIRDIFF))
    {
      filtFactor = MAFT_FILTVAL;
      filtShifts = 0;
      /* We aim to produce a result in the accumulator field
       * between -255 and +255.
       *
       * Hence, to get the `notfilt' tableInfoPtr
       * required to multiply AFTFILTVAL
       * by to get 255*heseries[k], we proceed as follows:
       */
      notFiltFactor = frexp (((double)
                              GLACE_CFG(heseriesSeries[GLACE_TRM(termNum)]))
                              * 255.0 / MAFT_FILTVAL / NOT_FILTVAL,
                              &notFiltShifts) * NOT_FILTVAL;
      abFactor = frexp (((double) GLACE_CFG(addbackSeries[GLACE_TRM(termNum)]))
                              * 255.0 / MAFT_FILTVAL / NOT_FILTVAL,
                              &abShifts) * NOT_FILTVAL;
    }
  else
    {
      if (GLACE_TRM(termType) == GLACE_COS)
        area = (2.0 * GLACE_CFG(windCWSeries[GLACE_TRM(termNum)]) + 1)
          * (2 * GLACE_CFG(windCHSeries[GLACE_TRM(termNum)]) + 1);
      else
        area = (2.0 * GLACE_CFG(windSWSeries[GLACE_TRM(termNum)]) + 1)
          * (2 * GLACE_CFG(windSHSeries[GLACE_TRM(termNum)]) + 1);

      filtFactor = frexp (1.0 / area, &filtShifts) * AFT_FILTVAL;
      filtShifts = -filtShifts;
      notFiltFactor = frexp (((double)
                              GLACE_CFG(heseriesSeries[GLACE_TRM(termNum)]))
                              * 255.0 / AFT_FILTVAL / NOT_FILTVAL +FLT_MIN,
                              &notFiltShifts) * NOT_FILTVAL;
      abFactor = frexp (((double) GLACE_CFG(addbackSeries[GLACE_TRM(termNum)]))
                              * 255.0 / AFT_FILTVAL / NOT_FILTVAL +FLT_MIN,
                              &abShifts) * NOT_FILTVAL;
    }

  /* 
   * The tableInfoPtr of 2 means that the effect of the addback does not
   * overflow.  -2<= ( cos(...)-addback ) <=1
   *
   * The idea of this is that the unfiltered (co)sine table is
   * already in the right place, and that the range of the filtered
   * field will occupy BIG_TMP_BITS bits for max postive number.
   *
   * Note that the notFiltShifts is the number of left shifts
   * to generate a result in the range -255 to +255. 
   */

  /*
   * NO NEED IF WE ADD FLT_MIN ABOVE *
  if (notFiltFactor==0.0)
    {
      notFiltFactor=1.0;
      notFiltShifts = (FORCE_NO_BIT_SHIFT);
    }
  if (abFactor==0.0)
    {
      abFactor=1.0;
      abShifts = (FORCE_NO_BIT_SHIFT);
    }
    */

  /* GLACE_MAXMAXGRAY is prescale/2 of a half-wave
   * (Fourier series truncation). */
  waveFactor = (2 * GLACE_TRM(termNum) - 1) * GLACE_PI / GLACE_MAXMAXGRAY
    * GLACE_CFG(prescaleVal) / 2;

  if (GLACE_TRM(termType) == GLACE_SIN)
    {
      if (abShifts < notFiltShifts)
	abFactor = ldexp(abFactor,abShifts-notFiltShifts);
      else
	{
	  notFiltFactor = ldexp(notFiltFactor,notFiltShifts-abShifts);
	  notFiltShifts = abShifts;
	}
    }
  
  /*
  if (GLACE_TRM(termType) == GLACE_COS)
    for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
      {
        GLACE_TRM(filtTable)[r] = filtFactor
          * cos ((r - GLACE_CFG(inoffsetVal)) * waveFactor);
        GLACE_TRM(notFiltTable)[r] = notFiltFactor
          * sin ((r - GLACE_CFG(inoffsetVal)) * waveFactor);
      }
  else
    for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
      {
	GLACE_TRM(filtTable)[r] = filtFactor
	  * sin ((r - GLACE_CFG(inoffsetVal)) * waveFactor);
	GLACE_TRM(notFiltTable)[r] = -1*((long) (notFiltFactor
            * (cos ((r - GLACE_CFG(inoffsetVal)) * waveFactor))
            - abFactor));
      }
  */
  
  if ((GLACE_CFG(outputMethod) == GLACE_SINRAW) ||
      (GLACE_CFG(outputMethod) == GLACE_COSRAW) ||
      (GLACE_CFG(filtMethod) == GLACE_DIRDIFF))
    GLACE_TRM(accShift) = (-notFiltShifts - MSHIFT + OUT_BITS - ACC_BITS);
  else
    GLACE_TRM(accShift) = (-notFiltShifts - BSHIFT + OUT_BITS - ACC_BITS);

  GLACE_TRM(filtFactor) = filtFactor;
  GLACE_TRM(filtShifts) = filtShifts;
  GLACE_TRM(notFiltFactor) = notFiltFactor;
  GLACE_TRM(notFiltShifts) = notFiltShifts;
  GLACE_TRM(abFactor) = abFactor;
  GLACE_TRM(abShifts) = abShifts;
  GLACE_TRM(waveFactor) = waveFactor;
}


/**************************************************************/
/*
 * :FUNCTION: Glace_FillTableForFilt
 */
void 
Glace_FillTableForFilt (
			Glace_CfgInfo *cfgInfoPtr,
			Glace_TableInfo *tableInfoPtr,
			float scale
			)
{
  int r;
  float sfac;

  sfac = scale * GLACE_TRM(filtFactor);

  if (GLACE_CFG(doublep)==GLACE_FALSE)
    if (GLACE_TRM(termType) == GLACE_COS)
      for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
	{
	  GLACE_TRM(seriesTable)[r] = 0.5+sfac
	    * cos ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	}
    else
      for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
	{
	  GLACE_TRM(seriesTable)[r] = 0.5+sfac
	    * sin ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	}
  else
    if (GLACE_TRM(termType) == GLACE_COS)
      for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
	{
	  GLACE_TRM(seriesAH)[r] = sfac
	    * cos ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	  GLACE_TRM(seriesBH)[r] = -sfac
	    * sin ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	  GLACE_TRM(seriesAL)[r] = 
	    cos (r * GLACE_TRM(waveFactor)/256);
	  GLACE_TRM(seriesBL)[r] = 
	    sin (r * GLACE_TRM(waveFactor)/256);
	}
    else
      for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
	{
	  GLACE_TRM(seriesAH)[r] = sfac
	    * sin ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	  GLACE_TRM(seriesBH)[r] = sfac
	    * cos ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	  GLACE_TRM(seriesAL)[r] = 
	    cos (r * GLACE_TRM(waveFactor)/256);
	  GLACE_TRM(seriesBL)[r] = 
	    sin (r * GLACE_TRM(waveFactor)/256);
	}
}


/**************************************************************/
/*
 * :FUNCTION: Glace_FillTableForNotFilt

 */
void 
Glace_FillTableForNotFilt (
			Glace_CfgInfo *cfgInfoPtr,
			Glace_TableInfo *tableInfoPtr
			)
{
  int r;
  float sfac;

  sfac = GLACE_TRM(notFiltFactor);

  if (GLACE_CFG(doublep)==GLACE_FALSE)
    if (GLACE_TRM(termType) == GLACE_COS)
      for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
	{
	  GLACE_TRM(seriesTable)[r] = 0.5+sfac
	    * sin ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	}
    else
      for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
	{
	  GLACE_TRM(seriesTable)[r] = 0.5+-1*((double) (sfac
            * (cos ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor)))
            - GLACE_TRM(abFactor) ));
	}
  else
    if (GLACE_TRM(termType) == GLACE_COS)
      for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
	{
	  GLACE_TRM(seriesAH)[r] = sfac
	    * cos ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	  GLACE_TRM(seriesBH)[r] = -sfac
	    * sin ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	}
    else
      for (r = 0; r <= GLACE_MAXMAXGRAY; r++)
	{
	  GLACE_TRM(seriesAH)[r] = sfac
	    * sin ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	  GLACE_TRM(seriesBH)[r] = sfac
	    * cos ((r - GLACE_CFG(inoffsetVal)) * GLACE_TRM(waveFactor));
	}
}






/**************************************************************/
/* Output accImgPtr */

/* :*** Overall Process ***:

 * :FUNCTION: Glace_WindChk
 */
void 
Glace_WindChk (
               Glace_CfgInfo *cfgInfoPtr,
               int rows, int cols
)
{
  unsigned int k;
  char message[MAX_MESSAGE_LEN];
  int r;

  if (GLACE_CFG(filtMethod) == GLACE_WINDOW)
    for (k = GLACE_CFG(firstTerm); k <= (unsigned) GLACE_CFG(numTerms); k++)
      {
        r = 1;
        if ((signed) (2 * GLACE_CFG(windSWSeries[k])) >= cols)
          sprintf (message, "Sine window width (%3d:%5d) "
                   "too large for image.", k,
                   GLACE_CFG(windSWSeries[k]));
        else if ((signed) (2 * GLACE_CFG(windCHSeries[k])) >= rows)
          sprintf (message, "Cosine window height (%3d:%5d) "
                   "too large for image.", k,
                   GLACE_CFG(windCHSeries[k]));
        else if ((signed) (2 * GLACE_CFG(windSHSeries[k])) >= cols)
          sprintf (message, "Sine window height (%3d:%5d) "
                   "too large for image.", k,
                   GLACE_CFG(windSHSeries[k]));
        else if ((signed) (2 * GLACE_CFG(windCWSeries[k])) >= rows)
          sprintf (message, "Cosine window width (%3d:%5d) "
                   "too large for image.", k,
                   GLACE_CFG(windCWSeries[k]));
        else if ((signed) (2 * GLACE_CFG(windSWSeries[k])) < 3)
          sprintf (message, "Sine window width (%3d:%5d) "
                   "too small.", k, GLACE_CFG(windSWSeries[k]));
        else if ((signed) (2 * GLACE_CFG(windCHSeries[k])) < 3)
          sprintf (message, "Cosine window height (%3d:%5d) "
                   "too small.", k, GLACE_CFG(windCHSeries[k]));
        else if ((signed) (2 * GLACE_CFG(windSHSeries[k])) < 3)
          sprintf (message, "Sine window height (%3d:%5d) "
                   "too small.", k, GLACE_CFG(windSHSeries[k]));
        else if ((signed) (2 * GLACE_CFG(windCWSeries[k])) < 3)
          sprintf (message, "Cosine window width (%3d:%5d) "
                   "too small.", k, GLACE_CFG(windCWSeries[k]));
        else
          r = 0;
        if (r)
          {
            Glace_WError( GLACE_CFG(wData),message);
            return;
          }
      }
}


/**************************************************************/
/*
 * :FUNCTION: Glace_TermlyReport
 */
void 
Glace_TermlyReport (
               Glace_CfgInfo *cfgInfoPtr,
                 Glace_TableInfo *tableInfoPtr
)
{
  char message[MAX_MESSAGE_LEN];

  if (GLACE_CFG(verbose))
    {
      if (GLACE_CFG(filtMethod) == GLACE_WINDOW)
        sprintf (message, "%5u: %5d %5d %5d %5d  %12.6g %12.6g",
                 GLACE_TRM(termNum),
                 GLACE_CFG(windCWSeries[GLACE_TRM(termNum)]),
                 GLACE_CFG(windCHSeries[GLACE_TRM(termNum)]),
                 GLACE_CFG(windSWSeries[GLACE_TRM(termNum)]),
                 GLACE_CFG(windSHSeries[GLACE_TRM(termNum)]),
                 GLACE_CFG(heseriesSeries[GLACE_TRM(termNum)]),
                 GLACE_CFG(addbackSeries[GLACE_TRM(termNum)]));
      else
        sprintf
          (message,
           "%5u: %5d %5d  %12.6g %12.6g",
           GLACE_TRM(termNum),
           GLACE_CFG(GLACE_CFG_COSDIM[GLACE_TRM(termNum)]),
           GLACE_CFG(GLACE_CFG_SINDIM[GLACE_TRM(termNum)]),
           GLACE_CFG(heseriesSeries[GLACE_TRM(termNum)]),
           GLACE_CFG(addbackSeries[GLACE_TRM(termNum)]));
      Glace_WMessage( GLACE_CFG(wData), message );
    }
}


/**************************************************************/
/*
 * :FUNCTION: Glace_DiagGen
 */
void 
Glace_DiagGen (
               Glace_CfgInfo *cfgInfoPtr,
               Glace_TableInfo *tableInfoPtr,
               Glace_ImgArrays *imgArraysPtr
)
{
  long r;
  Glace_Gray *hgP, *lgP;
  Glace_MidGray *mgP, *ogP;
  Glace_BigGray *bgP;
  register Glace_FpSeries *thisAH, *thisAL, *thisBH, *thisBL;

  if ((GLACE_CFG(outputMethod) == GLACE_COSFILT)
      || (GLACE_CFG(outputMethod) == GLACE_COSRAW))
    Glace_SetForTerm(tableInfoPtr, GLACE_CFG(numTerms), GLACE_COS);
  else
    Glace_SetForTerm(tableInfoPtr, GLACE_CFG(numTerms), GLACE_SIN);

  Glace_TermlyReport( cfgInfoPtr, tableInfoPtr);

  Glace_SetTables (cfgInfoPtr, tableInfoPtr);
  

  if ((GLACE_CFG(outputMethod) == GLACE_COSFILT)
      || (GLACE_CFG(outputMethod) == GLACE_SINFILT))
    {
      Glace_FillTableForFilt (cfgInfoPtr,tableInfoPtr,1.0);
      Glace_CallFilt ( cfgInfoPtr, tableInfoPtr, imgArraysPtr);
    }

  else if ((GLACE_CFG(outputMethod) == GLACE_SINRAW)
           || (GLACE_CFG(outputMethod) == GLACE_COSRAW))
    {
      Glace_FillTableForFilt (cfgInfoPtr,tableInfoPtr,1.0);

      if (GLACE_CFG(doublep) ==GLACE_FALSE)
	for (r = 0, hgP = GLACE_IMG(refImgHBPtr),
	       mgP = (Glace_MidGray *) GLACE_IMG(tmpImgPtr);
	     r < GLACE_IMG(rows)*GLACE_IMG(cols); r++, mgP++, hgP++)
	  *mgP = GLACE_TRM(seriesTable)[*hgP];
      else
	{
	  thisAH = GLACE_TRM(seriesAH);
	  thisAL = GLACE_TRM(seriesAL);
	  thisBH = GLACE_TRM(seriesBH);
	  thisBL = GLACE_TRM(seriesBL);
	  
	  for (r = 0, hgP = GLACE_IMG(refImgHBPtr),
		 lgP = GLACE_IMG(refImgLBPtr),
		 mgP = (Glace_MidGray *) GLACE_IMG(tmpImgPtr);
	       r < GLACE_IMG(rows)*GLACE_IMG(cols); r++, mgP++, hgP++, lgP++)
	    *mgP = thisAH[*hgP]*thisAL[*lgP] +
	      thisBH[*hgP]*thisBL[*lgP] +0.5;
	}
    }
  
  
  
  if (GLACE_IMG(tmpImgGraySize) == sizeof(Glace_BigGray))
    for (r = 0, bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),
           ogP = GLACE_IMG(outAccImgPtr);
         r < GLACE_IMG(rows)*GLACE_IMG(cols); r++, bgP++, ogP++)
      *ogP = (*bgP) >> (BIG_TMP_BITS - ACC_BITS);
  else
    for (r = 0, mgP = (Glace_MidGray *) GLACE_IMG(tmpImgPtr),
           ogP = GLACE_IMG(outAccImgPtr);
         r < GLACE_IMG(rows)*GLACE_IMG(cols); r++, mgP++, ogP++)
      *ogP = (*mgP) >> (MID_TMP_BITS - ACC_BITS);

  if (GLACE_CFG(verbose))
    Glace_WMessage( GLACE_CFG(wData), ";\n" );
}


/**************************************************************/

/**************************************************************/
/*
 * :FUNCTION: Glace_Process
 */
void 
Glace_Process (
               Glace_WData wData,
               Glace_CfgInfo *cfgInfoPtr,
              Glace_TableInfo *tableInfoPtr,
               Glace_ImgArrays *imgArraysPtr
)
{
  unsigned int k;

  Glace_WindChk (cfgInfoPtr, GLACE_IMG(cols), GLACE_IMG(rows));
  GLACE_ERROR_CHECK( GLACE_CFG(wData) );

  Glace_InitAccIm (cfgInfoPtr, imgArraysPtr);

  if (GLACE_CFG(outputMethod) == GLACE_NORMAL)
    for (k = GLACE_CFG(firstTerm); k <= (unsigned) GLACE_CFG(numTerms); k++)
      {
        
        Glace_SetForTerm(tableInfoPtr, k, GLACE_COS);
        Glace_TermlyReport( cfgInfoPtr, tableInfoPtr);
        
        Glace_SetTables (cfgInfoPtr, tableInfoPtr);
        Glace_GenGen ( cfgInfoPtr, tableInfoPtr, imgArraysPtr);
	GLACE_ERROR_CHECK( GLACE_CFG(wData) );
        
        Glace_SetForTerm(tableInfoPtr, k, GLACE_SIN);
        
        Glace_SetTables (cfgInfoPtr, tableInfoPtr);
        Glace_GenGen ( cfgInfoPtr, tableInfoPtr, imgArraysPtr);
	GLACE_ERROR_CHECK( GLACE_CFG(wData) );

	if (GLACE_CFG(verbose))
	  Glace_WMessage( GLACE_CFG(wData), ";\n" );
      }
  else
    Glace_DiagGen (cfgInfoPtr, tableInfoPtr, imgArraysPtr);
  GLACE_ERROR_CHECK( GLACE_CFG(wData) );
  Glace_Output (wData, cfgInfoPtr, imgArraysPtr );
}


/*************************************************************/


/* :*** Argument Parsing ***:

 * :FUNCTION: GlaceArgError
 */
int
GlaceArgError (
             Glace_WData wData,
               const char *message,
               char *argv[],
               int numArgs,
               int problemArg
               )

{
   char argErrStr[GLACE_STRMAX+201];
   char *sp;
   int spaceleft;
   int k;

   sp = &argErrStr[0];
  
   strncpy( sp, message, 100 );
   sp += strlen(sp);

   sprintf( sp, "\nargument number: %u\n\t\"", problemArg );
   sp += strlen(sp);
   for (k=0, spaceleft=GLACE_STRMAX;
        (k<numArgs) && (spaceleft>0);
        k++)
   {
      strncpy( sp, argv[problemArg+k], spaceleft );

      spaceleft -= strlen(sp);
      sp += strlen(sp);
      *sp++ = ' ';
   } 
   sprintf( --sp, "\"" );

   return Glace_WError( wData,argErrStr);
}


/**************************************************************/
/*
 * :FUNCTION: Glace_ParseArgs
 */
int
Glace_ParseArgs (
   Glace_CfgInfo *cfgInfoPtr,
   Glace_ImgArrays *imgArraysPtr,
   int argc,
   char *argv[])
{

   int argn;
  
   char *usage = "OPTIONS [pgmfile]\n"
     "\t-reset  (reset configuration: use first\n"
     "\t\twhen calling as a library. Ignore on command line)\n"
      "\t\tMandatory arguments:\n"
      "\t<wind-width> <wind-height> <# terms> | ...\n"
      "\t-windlistfile <f> | ...\n"
      "\t<d-dim> <baseval> <# terms> -ddimages <horiz-pgm> <vert-pgm> | ...\n"
      "\t-ddimages <horiz-pgm> <vert-pgm> -ddlistfile <f> | ...\n"
      "\t\tOptions:\n"
      "\t-factor <alpha> | -seriesfile <s>\n"
     "\t-doublep   * double precision\n"
     "\t-cc | -cg | -gg | -cgd | -ggd\n"
     "\t\t* inputletter-outputletter pair (colour/gray)\n"
     "\t\t  -gg[d] and -doublep: split input r-ignore, g-high, b-low\n"
     "\t\t  d-suffix for double-precision output (split rgb/ppm)\n"
     /*     "\t\tppm input, -gg or -gc , w/o -doublep: read as pgm\n"*/
     "\t\t  -cc is overidden to -cg for diagnostic output\n"
     "\t\t  -cc and -cg are overidden with pgm input\n"
      "\t-cosraw | -cosfilt | -sinraw | -sinfilt | -clip\n"
      "\t-quiet | -verbose\n"
      "\t-hamming\n"
      "\t-prescale <p>\n"
      "\t-zaddback <a> | -laddback <a>\n"
      "\t-passthru <a>\n"
      "\t-onlyheseries   * coefficient windowing\n"
      "\t-tolerance <tol>   * -1 disables\n"
      "\t-inoffset <v>\n"
      "\t-gauss <w>\n"
      "\t-refimage <pgmfile>\n"
      "\t-cumulation <min> <max> <num-points>  * c-function\n"
      "Options may come in any sensible order: valueless ones like"
      "-verbose must\nnot come last. "
      "They may be abbreviated.\n"
      "\t** Base values are ignored in dd filtering.\n";
   /* Remaining letters: bejkmnuxy */
  
   /* Indicators to check if option already scanned.
      These contain the index into argv of the relevant argument. */
   int vprescale=0, vaddback=0, vinoffset=0, vwlistfile=0, vdimensions=0,
     vseriesfile=0, vfactor=0, vddimages=0, vddlistfile=0, vtype=0, vtol=0,
     vrefimage=0, vgauss=0, vcfunc=0, vinput=0, voutput=0, vpassthru=0;
   /* The following are just overruled by a later argument:
    * sinraw, sinfilt, cosraw, cosfilt, verbose, quiet.
    * hamming cannot be turned off later.
    */
   int last_arg;


   argn = 1;

   if (argc<=1)
     {
       Glace_WUsage (GLACE_CFG(wData), usage);
       return Glace_WErrorValue( GLACE_CFG(wData) );
     }

   do {
      last_arg=argn;

      if (Glace_WKeyMatch (argv[argn], "-reset", 4))
      {
         Glace_CfgInit ( cfgInfoPtr );
         argn++;
      }
      else if (Glace_WKeyMatch (argv[argn], "-cosraw", 5))
      {
         vtype = argn++;
         GLACE_CFG(outputMethod) = GLACE_COSRAW;
      }
      else if (Glace_WKeyMatch (argv[argn], "-sinraw", 5))
      {
         vtype = argn++;
         GLACE_CFG(outputMethod) = GLACE_SINRAW;
      }
      else if (Glace_WKeyMatch (argv[argn], "-cosfilt", 5))
      {
         vtype = argn++;
         GLACE_CFG(outputMethod) = GLACE_COSFILT;
      }
      else if (Glace_WKeyMatch (argv[argn], "-sinfilt", 5))
      {
         vtype = argn++;
         GLACE_CFG(outputMethod) = GLACE_SINFILT;
      }
      else if (Glace_WKeyMatch (argv[argn], "-clip", 3))
      {
         vtype = argn++;
         GLACE_CFG(doClip) = GLACE_TRUE;
         GLACE_CFG(outputMethod) = GLACE_NORMAL;
      }
      else if (Glace_WKeyMatch (argv[argn], "-quiet", 2))
      {
         GLACE_CFG(verbose) = GLACE_FALSE;
         argn++;
      }
      else if (Glace_WKeyMatch (argv[argn], "-verbose", 2))
      {
         GLACE_CFG(verbose) = GLACE_TRUE;
         argn++;
      }
      else if (Glace_WKeyMatch (argv[argn], "-refimage", 4))
      {
         vrefimage = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-input", 4))
      {
         vinput = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-output", 4))
      {
         voutput = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-hamming", 2))
      {
         GLACE_CFG(hammingCwind) = GLACE_TRUE;
         argn++;
      }
      else if (Glace_WKeyMatch (argv[argn], "-prescale", 3))
      {
         vprescale = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-passthru", 2))
      {
         vpassthru = argn;
         GLACE_CFG(addbackMode) = GLACE_COMMANDLINE;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-zaddback", 2))
      {
         vaddback = argn;
         GLACE_CFG(addbackType) = GLACE_ZEROINPUT;
         GLACE_CFG(addbackMode) = GLACE_COMMANDLINE;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-laddback", 2))
      {
         vaddback = argn;
         GLACE_CFG(addbackType) = GLACE_LOCALMEAN;
         GLACE_CFG(addbackMode) = GLACE_COMMANDLINE;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-onlyheseries", 5))
      {
         GLACE_CFG(addbackCwind) = GLACE_FALSE;
         argn++;
      }
      else if (Glace_WKeyMatch (argv[argn], "-gauss", 3))
      {
         vgauss = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-inoffset", 2))
      {
         vinoffset = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-factor", 2))
      {
         vfactor = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-windlistfile", 2))
      {
         vwlistfile = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-seriesfile", 2))
      {
         vseriesfile = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-ddlistfile", 4))
      {
         vddlistfile = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-ddimages", 4))
      {
         vddimages = argn;
         argn +=3;
      }
      else if (Glace_WKeyMatch (argv[argn], "-cumulation", 3))
      {
         vcfunc = argn;
         argn +=4;
      }
      else if (Glace_WKeyMatch (argv[argn], "-tolerance", 2))
      {
         vtol = argn;
         argn +=2;
      }
      else if (Glace_WKeyMatch (argv[argn], "-doublep", 2))
      {
         GLACE_CFG(doublep) = GLACE_TRUE;
         argn++;
      }
      else if (Glace_WKeyMatch (argv[argn], "-ggd", 4))
      {
         GLACE_CFG(chrome) = GLACE_GG;
         GLACE_CFG(doubleout) = GLACE_TRUE;
         argn++;
	 /* PNM: default for PGM input
	    +    and use to force reading PPM as gray*/
      }
      else if (Glace_WKeyMatch (argv[argn], "-gg", 3))
      {
         GLACE_CFG(chrome) = GLACE_GG;
         argn++;
	 /* PNM: default for PGM input
	    +    and use to force reading PPM as gray*/
      }
      else if (Glace_WKeyMatch (argv[argn], "-cgd", 4))
      {
         GLACE_CFG(chrome) = GLACE_CG;
         GLACE_CFG(doubleout) = GLACE_TRUE;
         argn++;
	 /* PNM: use to force gray output*/
      }
      else if (Glace_WKeyMatch (argv[argn], "-cg", 3))
      {
         GLACE_CFG(chrome) = GLACE_CG;
         argn++;
	 /* PNM: use to force gray output*/
      }
      else if (Glace_WKeyMatch (argv[argn], "-cc", 3))
      {
         GLACE_CFG(chrome) = GLACE_CC;
         argn++;
	 /* PNM: default for PPM input and hence irrelevant */
      }
      else
      {
         vdimensions = argn;
         argn +=3;
      }
   }
   while (argn<(argc-1));


   /* Possiblities here: (note argc=#args +1)
    *
    * Last argument must not be single, eg -verbose
    *
    * Single final argument must be filename or `-':   argn==argc-1
    * Standard input assumed otherwise:                argn==argc-1+1
    * Error if we have overspilled:                    argn >argc-1+1
    */
  
   if (argn > (argc))
      return GlaceArgError( GLACE_CFG(wData),
                            "Final option was missing a value.",
                     argv, argc-last_arg, last_arg);
  
   /* Input stream is opened at end of this procedure, so that
      earlier errors are indicated first. */
  
   /* ************************************************************ */
   /* Check types of operation. */

   /* DIAGNOSTIC (sinfilt etc. override -clip when coming after) */
   if (GLACE_CFG(outputMethod) != GLACE_NORMAL)
     {
         GLACE_CFG(doClip) = GLACE_FALSE;
     }

   /* HETYPE */
   if (vfactor>0)
   {
      if (vseriesfile>0)
         return GlaceArgError( GLACE_CFG(wData),
                               "Option conflict: seriesfile with factor.",
                        argv, 2, vseriesfile);
      GLACE_CFG(heType) = GLACE_FACTOR;
   }
   else if (vseriesfile>0)
     {
       GLACE_CFG(heType) = GLACE_SERIES;
        GLACE_CFG(sListfile)  = fopen (argv[vseriesfile+1], "rt");
       if ( GLACE_CFG(sListfile)  == NULL)
         return GlaceArgError( GLACE_CFG(wData),
                               "Unable to open series list file.",
                        argv, 2, vseriesfile);
     }

   /* FILTMETHOD & DIMENSIONSRC */
   if (vddimages>0)
   {
      if (vwlistfile>0)
         return GlaceArgError( GLACE_CFG(wData),
                               "Option conflict: windlistfile with ddimages.",
                        argv, 2, vwlistfile);
      GLACE_CFG(filtMethod) = GLACE_DIRDIFF;
      if (vddlistfile>0)
        {
          GLACE_CFG(dimensionSrc) = GLACE_LISTFILE;
           GLACE_CFG(dListfile)  = fopen (argv[vddlistfile+1], "rt");
          if ( GLACE_CFG(dListfile)  == NULL)
            return GlaceArgError( GLACE_CFG(wData),
                                  "Unable to open window list file.",
                           argv, 2, vddlistfile);
        }

  
   }
   else if (vwlistfile>0)
   {
      if (vddlistfile>0)
         return GlaceArgError( GLACE_CFG(wData),
                               "Option conflict: ddlistfile"
                               " with windlistfile.",
                        argv, 2, vddlistfile);
      GLACE_CFG(dimensionSrc) = GLACE_LISTFILE;

       GLACE_CFG(wListfile)  = fopen (argv[vwlistfile+1], "rt");
      if ( GLACE_CFG(wListfile) == NULL)
        return GlaceArgError( GLACE_CFG(wData),
                              "Unable to open window list file.",
                       argv, 2, vwlistfile);
        
   }
   else if (vddlistfile>0)
      return GlaceArgError( GLACE_CFG(wData),
                            "Option ddlistfile requires ddimages.",
                     argv, 2, vddlistfile);

   if (vdimensions>0)
      if (GLACE_CFG(dimensionSrc) == GLACE_LISTFILE)
         return GlaceArgError( GLACE_CFG(wData),
                        "Option conflict: dimensions with a listfile.",
                        argv, 3, vdimensions);
      else 
        {
          GLACE_CFG(dimensionSrc) = GLACE_COMMANDLINE;
          /* read window/dd parameters from next three args. */
          GLACE_CFG(windBaseW) = atoi (argv[vdimensions]);
          GLACE_CFG(windBaseH) = atoi (argv[vdimensions+1]);
          GLACE_CFG(numTerms) = atoi (argv[vdimensions+2]);
          if (GLACE_CFG(numTerms) < 0)
            return GlaceArgError( GLACE_CFG(wData),
                                  "Number of terms must be a"
                                  " positive integer.",
                                  argv, 3, vdimensions);
          if (GLACE_CFG(numTerms) == 0)
	    {
	      if (GLACE_CFG(wrapType)==GLACE_TK_VER)
		GLACE_CFG(plainGlace) = GLACE_FALSE;
	      else
		return GlaceArgError( GLACE_CFG(wData),
				      "Number of terms must be"
				      " greater than zero.",
				      argv, 3, vdimensions);
	    }
          if (GLACE_CFG(plainGlace) == GLACE_TRUE)
            {
              if (GLACE_CFG(numTerms) > GLACE_CFG_DEFAULT_NUM_TERMS)
                return GlaceArgError( GLACE_CFG(wData),
                                      "The maximum number of terms is 200.",
                                      argv, 3, vdimensions);
              
              if (GLACE_CFG(filtMethod) == GLACE_WINDOW)
		{
		  if (GLACE_CFG(windBaseW) < 3 || GLACE_CFG(windBaseH) < 3)
		    return GlaceArgError( GLACE_CFG(wData),
					  "Dimensions integers must"
					  " be greater than 2.",
					  argv, 3, vdimensions);
		  else
		    if (GLACE_CFG(windBaseW) < 1 || GLACE_CFG(windBaseH) < 0)
		      return GlaceArgError( GLACE_CFG(wData),
					    "Dimension >=1 and baseval >0.",
					    argv, 3, vdimensions);
		}
            }
        }
   else if (GLACE_CFG(dimensionSrc) == GLACE_MISSING)
     return GlaceArgError( GLACE_CFG(wData),"Filter specification required.",
                           argv, 0, vddlistfile);
   

   /* ************************************************************ */
   /* Extract argument information. */
 
   /* PRESCALE */
   if (vprescale>0)
   {
      GLACE_CFG(prescaleMode) = GLACE_COMMANDLINE;
      GLACE_CFG(prescaleVal) = atof (argv[vprescale+1]);
      if ( (GLACE_CFG(prescaleVal) < 0) || (GLACE_CFG(prescaleVal) > 2) )
         return GlaceArgError( GLACE_CFG(wData),
                        "Prescale argument should be between 0 and 2.",
                        argv, 2, vprescale);
   }

   /* FACTOR */
   if (vfactor>0)
   {
     GLACE_CFG(heFactor) = (float) atof (argv[vfactor+1]);
      if (GLACE_CFG(heFactor)>1)
        GLACE_CFG(heFactor) = GLACE_CFG(heFactor)/100.0;
      if ( (GLACE_CFG(heFactor) < 0.0) || (GLACE_CFG(heFactor) > 1.0) )
         return GlaceArgError( GLACE_CFG(wData),
                        "Factor argument should be between 0 and 1.",
                        argv, 2, vfactor);
   }
   
   /* ADDBACK */
   if (vaddback>0)
   {
      GLACE_CFG(addbackFactor) = atof (argv[vaddback+1]);
      if ( (GLACE_CFG(addbackFactor) < 0.0) ||
           (GLACE_CFG(addbackFactor) > 1.0) )
         return GlaceArgError( GLACE_CFG(wData),
                        "Addback argument should be between 0 and 1.",
                        argv, 2, vaddback);
   }
   if (vpassthru>0)
   {
      GLACE_CFG(passthruFactor) = atof (argv[vpassthru+1]);
      if ( (GLACE_CFG(passthruFactor) < 0.0) ||
           (GLACE_CFG(passthruFactor) > 1.0) )
         return GlaceArgError( GLACE_CFG(wData),
                        "Passthru argument should be between 0 and 1.",
                        argv, 2, vpassthru);
   }

   /* INOFFSET */
   if (vinoffset>0)
   {
      GLACE_CFG(inoffsetMode) = GLACE_COMMANDLINE;
      GLACE_CFG(inoffsetVal) = atof (argv[vinoffset+1]);
      if ( (GLACE_CFG(inoffsetVal) < 0) ||
           (GLACE_CFG(inoffsetVal) > GLACE_MAXMAXGRAY) )
         return GlaceArgError( GLACE_CFG(wData),
                        "Input offset argument out of gray level range.",
                        argv, 2, vinoffset);
      if  ( (GLACE_CFG(inoffsetVal) > -0.000001) &&
            (GLACE_CFG(inoffsetVal) < 1.000001 ) )
        GLACE_CFG(inoffsetVal) = GLACE_CFG(inoffsetVal) * GLACE_MAXMAXGRAY;
   }
     
   /* GAUSSIAN SMOOTHING */
   if (vgauss>0)
   {
      GLACE_CFG(gaussCwindWidth) = atof (argv[vgauss+1]);
      if (GLACE_CFG(gaussCwindWidth) < 0.0)
         return GlaceArgError( GLACE_CFG(wData),
                        "Gaussian width argument must be nonnegative.",
                        argv, 2, vgauss);
      GLACE_CFG(gaussCwind) = GLACE_TRUE;
   }
  
   /* TOLERANCE */
   if (vtol>0)
   {
     GLACE_CFG(coeffTol) = (float) atof (argv[vtol+1]);
   }
   
   /* REFERENCE IMAGE */
   if (vrefimage>0)
   {   
     Glace_WOpenImage( GLACE_CFG(wData), cfgInfoPtr, argv[vrefimage+1],
                       &GLACE_IMG(refImageHandle) );
     GLACE_CFG(refimageMode) = GLACE_SEPARATE;
   }

   /* CUMULATION FUNCTION */
   if (vcfunc>0)
   {
      GLACE_CFG(genCFunc) = GLACE_TRUE;
      GLACE_CFG(cFuncMin) = atof (argv[vcfunc+1]);
      GLACE_CFG(cFuncMax) = atof (argv[vcfunc+2]);
      GLACE_CFG(cFuncPoints) = atol (argv[vcfunc+3]);
      if (GLACE_CFG(cFuncPoints) < 2)
         return GlaceArgError( GLACE_CFG(wData),
                        "Number of points in curve must be greater than 1.",
                        argv, 4, vcfunc);
   }
  
   /* OPEN INPUT */
   if (argn < argc)   /* `-' = stdin */
     Glace_WOpenImage( GLACE_CFG(wData), cfgInfoPtr, argv[argn],
                       &GLACE_IMG(inputImageHandle) );
   else if (argn == argc)
     Glace_WOpenImage( GLACE_CFG(wData), cfgInfoPtr, NULL,
		       &GLACE_IMG(inputImageHandle) );

   /* INPUT IMAGE */
   if (vinput>0)
     Glace_WOpenImage( GLACE_CFG(wData), cfgInfoPtr, argv[vinput+1],
                       &GLACE_IMG(inputImageHandle) );

   /* OUTPUT IMAGE */
   if (voutput>0)
     Glace_WOpenImage( GLACE_CFG(wData), cfgInfoPtr, argv[voutput+1],
                       &GLACE_IMG(outputImageHandle) );
   /* OPEN DIRECTION IMAGES */
   if (vddimages>0)
     {
       Glace_WOpenImage( GLACE_CFG(wData), cfgInfoPtr, argv[vddimages+1],
                         &GLACE_IMG(ddHImageHandle) );
       if (GLACE_IMG(ddHImageHandle) == NULL)
         return GlaceArgError( GLACE_CFG(wData),
                        "Unable to open first (horiz) image direction file.",
                        argv, 2, vddimages);
       Glace_WOpenImage( GLACE_CFG(wData), cfgInfoPtr, argv[vddimages+2],
                         &GLACE_IMG(ddVImageHandle) );
       if (GLACE_IMG(ddVImageHandle) == NULL)
         return GlaceArgError( GLACE_CFG(wData),
                        "Unable to open second (vert) image direction file.",
                        argv, 2, vddimages);
     }
 
   /* ********************************************************************** */
   return Glace_WErrorValue( GLACE_CFG(wData) );
}



/* :*** Cumulation Function ***:

 * :FUNCTION: Glace_CFuncGen
 */
int
Glace_CFuncGen (
                 Glace_CfgInfo *cfgInfoPtr
                 )
{
  char outText[20];
  float x, y;
  int i;

  if (GLACE_CFG(genCFunc))
    {
      if (GLACE_CFG(numTerms)!=GLACE_CFG(termsSerialised))
        return Glace_WError( GLACE_CFG(wData),
                      "Series arrays not correctly allocated before call to"
                      " cumulation\nfunction generator.");
      if (GLACE_CFG(verbose))
        Glace_WMessage( GLACE_CFG(wData), "Cumulation Function:\n"
                        "    x     y    ideal-y\n" );
      
      for (i=0; i<GLACE_CFG(cFuncPoints); i++)
        {
          x = i / ((double) GLACE_CFG(cFuncPoints)-1) ;
          x = GLACE_CFG(cFuncMax) * x + GLACE_CFG(cFuncMin) * (1-x);
          
          sprintf( outText, "%4g", (double) x) ;
          Glace_WMessage( GLACE_CFG(wData), outText );
          
          y = Glace_CFuncPoint( cfgInfoPtr, x);
          
          sprintf( outText, " %6g", (double) y) ;
          Glace_WMessage( GLACE_CFG(wData), outText );
          
          y = Glace_CFuncIdealPoint( cfgInfoPtr, x);
          
          sprintf( outText, " %6g\n", (double) y) ;
          Glace_WMessage( GLACE_CFG(wData), outText );
        }
    }
  return Glace_WErrorValue( GLACE_CFG(wData) );;
}


/**************************************************************/
/*
 * :FUNCTION: Glace_CFuncPoint
 */
float
Glace_CFuncPoint (
                Glace_CfgInfo *cfgInfoPtr,
                float x
                 )
{
  float y=0;
  int i;

  y = 2 * GLACE_CFG(passthruFactor)*x;

  for (i=1; i<= GLACE_CFG(numTerms); i++)
    y += GLACE_CFG(heseriesSeries)[i] *
      sin( (i-0.5)* GLACE_PI *x* GLACE_CFG(prescaleVal) );

  return y;
}

/**************************************************************/
/*
 * :FUNCTION: Glace_CFuncIdealPoint
 */
float
Glace_CFuncIdealPoint (
                Glace_CfgInfo *cfgInfoPtr,
                float x
                 )
{
  float y=0;

  if (x!=0)
    y = x/fabs(x) * pow( 2*fabs(x)* GLACE_CFG(prescaleVal),
                         GLACE_CFG(heFactor) );
  
  return y;
}

/*
 * fwheGLACE_CFGs.c:  GLACE_CFGument handling for pgmfwhe.c
 *
 * See that file for details!
 *
 * Version 3.0, VI-97: J.Alex Stark
 */


/**************************************************************/

/* :*** CONFIGURATION ***:

 * :FUNCTION: Glace_CfgInit
 */
void
Glace_CfgInit (
   Glace_CfgInfo *cfgInfoPtr
)
{
  Glace_WData wData;
  
  wData = GLACE_CFG(wData);

   /* The structure is pre-filled with zeros, and so
      r->outputmethod = NORMAL; etc.. */
   memset((cfgInfoPtr), '\0',sizeof(Glace_CfgInfo));

   GLACE_CFG(verbose) = GLACE_TRUE;
   GLACE_CFG(addbackCwind) = GLACE_TRUE;

   GLACE_CFG(numTerms) = GLACE_CFG_DEFAULT_NUM_TERMS;
   GLACE_CFG(inoffsetVal) = GLACE_MIDGRAY;

  GLACE_CFG(wData) = wData;
  GLACE_CFG(wrapType) = Glace_WWrapTell();
  GLACE_CFG(plainGlace) = GLACE_TRUE;

}


/**************************************************************/

/*
 * :FUNCTION: Glace_CfgFreeSeriesVectors
 */
void
Glace_CfgFreeSeriesVectors (
   Glace_CfgInfo *cfgInfoPtr
   )
{
    Glace_CallocReallocFree( GLACE_CFG(heseriesSeries),
                             &GLACE_CFG(currentSeriesAllocation),
                             0, 1, 0.4);

}


/**************************************************************/

/*
 * :FUNCTION: Glace_CfgAllocSeriesVectors
 */
void
Glace_CfgAllocSeriesVectors (
   Glace_CfgInfo *cfgInfoPtr
   )
{
  int newSeriesTerms;

  /* Note that we start the series from [1], and so the */

  /* round up to nearest ROUND_TERMS */
#define ROUND_TERMS (10)
  newSeriesTerms = ( (int) (GLACE_CFG(numTerms)/ROUND_TERMS) +1 )
    * ROUND_TERMS;

  GLACE_CFG(heseriesSeries) = (double *) 
    Glace_CallocReallocFree( GLACE_CFG(heseriesSeries),
                             &GLACE_CFG(currentSeriesAllocation),
                             newSeriesTerms,
                             3*sizeof( double ) + 4*sizeof( int ),
                             0.4);
      
  GLACE_CFG(cwindSeries)   =
    &GLACE_CFG(heseriesSeries)[newSeriesTerms];
  GLACE_CFG(addbackSeries) =
    &GLACE_CFG(heseriesSeries)[newSeriesTerms*2];
  GLACE_CFG(windCWSeries)  = (int *)
    &GLACE_CFG(heseriesSeries)[newSeriesTerms*3];
  GLACE_CFG(windCHSeries)  =
    &GLACE_CFG(windCWSeries)[newSeriesTerms];
  GLACE_CFG(windSWSeries)  =
    &GLACE_CFG(windCWSeries)[newSeriesTerms*2];
  GLACE_CFG(windSHSeries)  =
    &GLACE_CFG(windCWSeries)[newSeriesTerms*3];

  GLACE_CFG(termsSerialised) = GLACE_CFG(numTerms);

}

/**************************************************************/

/*
 * :FUNCTION: Glace_CfgBeginToHeseries
 */
void
Glace_CfgBeginToHeseries (
   Glace_CfgInfo *cfgInfoPtr
   )
{
   int j;
   int  windw, windh;

   double hamma, hammb;
   struct Glace_HeseriesInfo hsi;



   for (j=1; j<=GLACE_CFG(numTerms); j++)
     GLACE_CFG(cwindSeries[j]) = 1.0;

   if ( GLACE_CFG(heType) != GLACE_FACTOR )
     GLACE_CFG(heFactor) = 0.0;


   /* SET TERM RANGE */
   /* if not normal we only output 1 term, ie the last */
   if (GLACE_CFG(outputMethod) == GLACE_NORMAL)
     GLACE_CFG(firstTerm) = 1;
   else
     GLACE_CFG(firstTerm) = GLACE_CFG(numTerms);
   

   /* PRESCALE */
   if ( GLACE_CFG(prescaleMode) == GLACE_MISSING )
     {
       if (GLACE_CFG(heType) == GLACE_STANDARD)
         GLACE_CFG(prescaleVal) = 1.7;
       else
         GLACE_CFG(prescaleVal) = 1.0;
     }

   /* ADDBACK */
   if ( GLACE_CFG(addbackMode) == GLACE_MISSING )
     {
       GLACE_CFG(addbackType) = GLACE_CFG_DEFAULT_A_WITH_F;
       GLACE_CFG(passthruFactor) = GLACE_CFG(heFactor);
       GLACE_CFG(addbackFactor) = 0.0;
       /*GLACE_CFG(addbackFactor) = GLACE_CFG(heFactor);*/
     }

   if (GLACE_CFG(filtMethod) == GLACE_WINDOW) { 
      /* WINDOW SIZES */
      if ( GLACE_CFG(dimensionSrc) == GLACE_LISTFILE )
      { /* Now in pgm scan listfiles */ }
      else if ( GLACE_CFG(dimensionSrc) == GLACE_COMMANDLINE )
      {
         if (GLACE_CFG(windBaseW) < 3 || GLACE_CFG(windBaseH) < 3)
            Glace_WError( GLACE_CFG(wData),
			  "Dimensions integers must be greater than 2.");
         if (GLACE_CFG(numTerms) <= 0)
            Glace_WError( GLACE_CFG(wData),
			  "Number of terms must be a positive integer.");
         if (GLACE_CFG(numTerms) > GLACE_CFG_DEFAULT_NUM_TERMS)
            Glace_WError( GLACE_CFG(wData),
			  "The maximum number of terms is 200.");
         /* convert to extent either side of pel */
         windw = GLACE_CFG(windBaseW) / 2;
         windh = GLACE_CFG(windBaseH) / 2;
         for (j = 1; j <= GLACE_CFG(numTerms); j++)
         {
            GLACE_CFG(windCWSeries[j]) = windw;
            GLACE_CFG(windSWSeries[j]) = windw;
            GLACE_CFG(windCHSeries[j]) = windh;
            GLACE_CFG(windSHSeries[j]) = windh;
         };
      }
   } else { /* DIRDIFF */
      if ( GLACE_CFG(dimensionSrc) == GLACE_LISTFILE )
      { /* Now in pgm scan listfiles */ }
      else if ( GLACE_CFG(dimensionSrc) == GLACE_COMMANDLINE )
      {
         if (GLACE_CFG(windBaseW) < 1 || GLACE_CFG(windBaseH) < 0)
            Glace_WError( GLACE_CFG(wData),"Dimension >=1 and baseval >0.");
         if (GLACE_CFG(numTerms) <= 0)
            Glace_WError( GLACE_CFG(wData),"Number of terms must be a positive integer.");
         if (GLACE_CFG(numTerms) > GLACE_CFG_DEFAULT_NUM_TERMS)
            Glace_WError( GLACE_CFG(wData),"The maximum number of terms is 200.");
         for (j = 1; j <= GLACE_CFG(numTerms); j++)
         {
            GLACE_CFG(GLACE_CFG_COSDIM[j]) = GLACE_CFG(windBaseW);
            GLACE_CFG(GLACE_CFG_SINDIM[j]) = GLACE_CFG(windBaseW);
            GLACE_CFG(GLACE_CFG_COSBV[j]) = GLACE_CFG(windBaseH);
            GLACE_CFG(GLACE_CFG_SINBV[j]) = GLACE_CFG(windBaseH);
         };
      }
   }    
        
   /* HE SERIES */
   if ( GLACE_CFG(heType) == GLACE_SERIES )
   { /* Now in pgm scan listfiles */ }
   else if ( GLACE_CFG(heType) == GLACE_FACTOR )
   {
      Glace_HeseriesInit(&hsi,GLACE_CFG(heFactor));
      for (j = 1; j <= GLACE_CFG(numTerms); j++)
        {
          GLACE_CFG(heseriesSeries[j]) = Glace_HeseriesVal(&hsi,j);
          if (GLACE_CFG(heseriesSeries[j]) ==GLACE_HESERIES_ERRORFLAG)
            Glace_WError( GLACE_CFG(wData),
                          "Error in Fourier series evaluation."); 
        }
   }
   else
   {
     for (j = 1; j <= GLACE_CFG(numTerms); j++)
       GLACE_CFG(heseriesSeries[j]) = 4 / GLACE_PI / (2 * j - 1);
   }

   for (j = 1, hamma=1; j <= GLACE_CFG(numTerms); j++, hamma *= -1)
     GLACE_CFG(heseriesSeries[j]) -=
       hamma * GLACE_CFG(passthruFactor)
       *16 /GLACE_PI  /GLACE_PI /(2 * j - 1) /(2 * j - 1);

   /* HAMMING WINDOWING */
   if (GLACE_CFG(hammingCwind)==GLACE_TRUE)
   {
     /*     hamma = 1/(0.54 + 0.46*cos(GLACE_PI/(2*GLACE_CFG(numTerms))));*/
     hamma = 1.0;
     hammb = 0.46*hamma;
     hamma = 0.54*hamma;
     for (j = 1; j <= GLACE_CFG(numTerms); j++)
       GLACE_CFG(cwindSeries[j]) = GLACE_CFG(cwindSeries[j])
         * (hamma + hammb*cos(GLACE_PI/(2*GLACE_CFG(numTerms))*(2 * j - 1)));
   }

   /* GAUSSIAN BLURRING */
   if ( GLACE_CFG(gaussCwind) == GLACE_TRUE )
   {
     hamma = -0.125*GLACE_PI*GLACE_PI/GLACE_MAXMAXGRAY/GLACE_MAXMAXGRAY
       * GLACE_CFG(prescaleVal) * GLACE_CFG(prescaleVal)
       * GLACE_CFG(gaussCwindWidth) * GLACE_CFG(gaussCwindWidth);
     for (j = 1; j <= GLACE_CFG(numTerms); j++)
       GLACE_CFG(cwindSeries[j]) = GLACE_CFG(cwindSeries[j])
         * exp(hamma*(2 * j - 1)*(2 * j - 1));
   }

   /* TOLERANCE */
   if ( GLACE_CFG(coeffTol) == 0.0 )
     {
       if ( GLACE_CFG(doublep) == GLACE_TRUE )
	 GLACE_CFG(coeffTol) = GLACE_TOL_DOUBLEP;
       else
	 GLACE_CFG(coeffTol) = GLACE_TOL_SINGLEP;
     }

   if ( (GLACE_CFG(doubleout) == GLACE_TRUE) && 
	(GLACE_CFG(doClip)==GLACE_TRUE))
     Glace_WError( GLACE_CFG(wData),
		   "-clip option conflicts with double-precision output."); 
}

/**************************************************************/

/*
 * :FUNCTION: Glace_CfgHeseriesToAddback
 */
void
Glace_CfgHeseriesToAddback (
   Glace_CfgInfo *cfgInfoPtr
   )
{
   int j;
   double hamma;

   
   /* ADDBACK SERIES */
   /* NOTE: If, in later versions, different addback amounts can be
      specified for each term, then a global factor is still
      required for the output offset. */
   if (GLACE_CFG(addbackType)==GLACE_ZEROINPUT )
     for (j = 1; j <= GLACE_CFG(numTerms); j++)
       GLACE_CFG(addbackSeries[j]) = GLACE_CFG(heseriesSeries[j])
         * GLACE_CFG(addbackFactor);
   else if (GLACE_CFG(addbackType)==GLACE_LOCALMEAN )
     for (j = 1, hamma=1; j <= GLACE_CFG(numTerms); j++, hamma *= -1)
       GLACE_CFG(addbackSeries[j]) = hamma * GLACE_CFG(addbackFactor)
         *16 /GLACE_PI  /GLACE_PI /(2 * j - 1) /(2 * j - 1);
   else if (GLACE_CFG(addbackType)==GLACE_NONE )
     for (j = 1; j <= GLACE_CFG(numTerms); j++)
       GLACE_CFG(addbackSeries[j]) = 0.0;

   /* APPLY COEFFICIENT WINDOW */
   for (j = 1; j <= GLACE_CFG(numTerms); j++)
     GLACE_CFG(heseriesSeries[j]) = GLACE_CFG(cwindSeries[j])
       * GLACE_CFG(heseriesSeries[j]);


}

/**************************************************************/

/*
 * :FUNCTION: Glace_CfgAddbackToEnd
 */
void
Glace_CfgAddbackToEnd (
   Glace_CfgInfo *cfgInfoPtr
   )
{
   int j;
   float total;

    if ( ((GLACE_CFG(outputMethod) != GLACE_NORMAL) ||
	  (GLACE_CFG(doClip)==GLACE_TRUE))
	&& (GLACE_CFG(chrome)==GLACE_CC))
      GLACE_CFG(chrome)=GLACE_CG;
      

   /* APPLY COEFFICIENT WINDOW */
   if ( GLACE_CFG(addbackCwind)==GLACE_TRUE )
   for (j = 1; j <= GLACE_CFG(numTerms); j++)
     GLACE_CFG(addbackSeries[j]) =
       GLACE_CFG(cwindSeries[j]) * GLACE_CFG(addbackSeries[j]);

   /* TRUNCATE PRECISION */
   for (j = 1; j <= GLACE_CFG(numTerms); j++)
     {
       GLACE_CFG(addbackSeries[j]) =
	 1.0 - (float) (1.0-GLACE_CFG(addbackSeries[j]));
       GLACE_CFG(heseriesSeries[j]) =
	 1.0 - (float) (1.0-GLACE_CFG(heseriesSeries[j]));
     }
   
   /* TOLERANCE */
   for (j = GLACE_CFG(numTerms), total = 0.0;
	((j>0) && (total < GLACE_CFG(coeffTol))) ; j--)
     total +=
       max(abs(GLACE_CFG(heseriesSeries[j])),
	   abs(GLACE_CFG(addbackSeries[j])));
   GLACE_CFG(activeTerms) = min(j+1,GLACE_CFG(numTerms));



   

   /*++++++++++ VERBOSITY POINT ++++++++++*/
   if (GLACE_CFG(verbose))
     {
       if ( GLACE_CFG(heType) == GLACE_FACTOR )
         fprintf (stderr, "HE factor: %f.\n", GLACE_CFG(heFactor));

       if ( GLACE_CFG(chrome) == GLACE_GG )
	 if ( GLACE_CFG(doublep) == GLACE_FALSE )
	   fprintf (stderr, "Gray input; ");
	 else
	   fprintf (stderr, "Two-byte gray input; ");
       else
         fprintf (stderr, "Colour input; ");
       if ( GLACE_CFG(doubleout) == GLACE_TRUE )
	 fprintf (stderr, "two-byte gray output.\n");
       else if ( GLACE_CFG(chrome) == GLACE_CC )
	   fprintf (stderr, "colour output.\n");
       else
	   fprintf (stderr, "gray output.\n");

       if ( GLACE_CFG(doublep) == GLACE_FALSE )
         fprintf (stderr, "Standard precision process.\n");
       else
         fprintf (stderr, "Two-byte precision process.\n");

       if ( GLACE_CFG(gaussCwind) == GLACE_TRUE )
         fprintf (stderr, "Gaussian smoother width: %f.\n",
                  GLACE_CFG(gaussCwindWidth));
       if (GLACE_CFG(hammingCwind)==GLACE_TRUE)
         fprintf (stderr, "Hamming windowing of HE series.\n");
       if (GLACE_CFG(refimageMode)==GLACE_SEPARATE)
         fprintf (stderr, "Using separate histogram reference image.\n");
       if ( GLACE_CFG(dimensionSrc) == GLACE_LISTFILE )
         fprintf (stderr, "Filter dimensions from listfile.\n");
       if ( GLACE_CFG(heType) == GLACE_SERIES )
         fprintf (stderr, "HE series coefficients from listfile.\n");

       fprintf (stderr, "Prescale: %f\tInput offset: %f.\n", 
                (double) GLACE_CFG(prescaleVal),
                (double) GLACE_CFG(inoffsetVal));

       if (GLACE_CFG(passthruFactor)>0 )
         fprintf (stderr, "Pass-thru, factor %f.\n",
                  (double) GLACE_CFG(passthruFactor));

       if (GLACE_CFG(addbackType)==GLACE_ZEROINPUT )
         fprintf (stderr, "Addback: zero-input, factor %f, ",
                  (double) GLACE_CFG(addbackFactor));
       else if (GLACE_CFG(addbackType)==GLACE_LOCALMEAN )
         fprintf (stderr, "Addback: local-mean, factor %f, ",
                  (double) GLACE_CFG(addbackFactor));
       
       if (GLACE_CFG(addbackType)!=GLACE_NONE )
	 {
	   if ( GLACE_CFG(addbackCwind)==GLACE_TRUE )
	     fprintf (stderr, "coefficients windowed/blurred.\n");
	   else
	     fprintf (stderr, "coefficients NOT windowed/blurred.\n");
	 }
       
       fprintf (stderr, "Coefficient tolerance %f; active terms %d.\n",
		(double) GLACE_CFG(coeffTol), GLACE_CFG(activeTerms));

       if (GLACE_CFG(outputMethod) == GLACE_SINRAW)
         fprintf (stderr, "DIAGNOSTIC OUTPUT: Raw sine field.\n");
       else if (GLACE_CFG(outputMethod) == GLACE_COSRAW)
         fprintf (stderr, "DIAGNOSTIC OUTPUT: Raw cosine field.\n");
       else if (GLACE_CFG(outputMethod) == GLACE_SINFILT)
         fprintf (stderr, "DIAGNOSTIC OUTPUT: Filtered sine field.\n");
       else if (GLACE_CFG(outputMethod) == GLACE_COSFILT)
         fprintf (stderr, "DIAGNOSTIC OUTPUT: Filtered cosine field.\n");
       else if (GLACE_CFG(doClip) == GLACE_TRUE)
         fprintf (stderr, "DIAGNOSTIC OUTPUT: Clipping field.\n");


       if (GLACE_CFG(filtMethod) == GLACE_WINDOW)
         fprintf (stderr, "Window filtering.\n"
                  "Term:  cos-w cos-h sin-w sin-h; series; addback.\n");
       else    
         fprintf (stderr, "Biased diffusion filtering.\n"
                  "Term:  cos-d sin-d; series; addback.\n");
     }


}



/* :*** SIGNED POWER-LAW HESERIES ***: 

 * :HEADER: (extras)
 */



typedef struct GlaceZHeseriesInfo
{
double heFactor;
double heFactorX;   /* 2-heFactor             */
double heGammaVal;     /* gamma(heFactorX)      */
double heTwoPower;       /* 2^heFactorX           */
double heSinVal;       /* sin( heFactorX*pi/2 ) */
double heBaseMag;      /* (1st coeff)/heTwoPower     */
  /* (this is kept so that relative errors
     for other coefficients can be found.) */
char dummy[GLACE_HESERIES_RESERVE - 6*sizeof(double)];
} GlaceZHeseriesInfo;

#define HE_FACTOR   ((GlaceZHeseriesInfo *) heseriesPtr)->heFactor
#define HE_FACTOR_X ((GlaceZHeseriesInfo *) heseriesPtr)->heFactorX
#define HE_GAMMA_VAL   ((GlaceZHeseriesInfo *) heseriesPtr)->heGammaVal
#define HE_TWO_POWER     ((GlaceZHeseriesInfo *) heseriesPtr)->heTwoPower
#define HE_BASE_MAG    ((GlaceZHeseriesInfo *) heseriesPtr)->heBaseMag
#define HE_GLACE_SIN_VAL     ((GlaceZHeseriesInfo *) heseriesPtr)->heSinVal





/*
 * :FUNCTION: Glace_HeseriesInit
 */
void
Glace_HeseriesInit (
     Glace_HeseriesInfo *heseriesPtr,
     float heFactor)
{
  double x, g;
  double omega_sq = GLACE_PI*GLACE_PI/4;
  double cstep, cprod, csum;

  /* simple bits */
  HE_FACTOR = heFactor;
  HE_FACTOR_X = 1+heFactor;

  /*
   * HE_GAMMA_VAL = gamma(HE_FACTOR_X)
   * absolute error < 3e-7
   *
   * See Abramowitz & Stegun
   */
  x = HE_FACTOR_X -1;
  g = ((0.035868343*x - 0.193527818)*x + 0.482199394)*x;
  g = ((g - 0.756704078)*x + 0.918206857)*x - 0.897056937;
  g = ((g*x + 0.988205891)*x - 0.577191652)*x + 1;
  HE_GAMMA_VAL = g;

  /*
   * HE_TWO_POWER = 2^HE_FACTOR_X
   */
  HE_TWO_POWER = pow(2.0, HE_FACTOR_X);

  /*
   * HE_BASE_MAG = 1st coefficient /HE_TWO_POWER
   * Series development (only require every other term)
   */
  cstep = HE_FACTOR_X;
  cprod = 1.0/cstep;
  csum  = cprod;
  while (fabs(cprod) > (10.0 * DBL_EPSILON * fabs(csum)))
    {
      cstep += 1.0;
      cprod *= -omega_sq /cstep;
      cstep += 1.0;
      cprod /= cstep;
      csum  += cprod;
    };
  HE_BASE_MAG = fabs(csum);

  HE_GLACE_SIN_VAL = sin(GLACE_PI*0.5*HE_FACTOR_X);
}

/* **************************************** */
/* CALCULATE SINGLE VALUE */

/*
 * :FUNCTION: Glace_HeseriesVal
 */
double
Glace_HeseriesVal (
     Glace_HeseriesInfo *heseriesPtr,
     int k)
{
  double p1r, p1i, p2r, p2i, q1r, q1i, q2r, q2i,
    omega, cold, cnew, tolval, n, normfact;
  
  if (k<0)
    {
      /*
      Glace_WError("Invalid request of HE series coefficient.\n");
      exit(1);
      */
      return GLACE_HESERIES_ERRORFLAG;
    }
  

  if (k==1)
    return HE_BASE_MAG*HE_TWO_POWER;
  else
    {
      tolval = 10.0*DBL_EPSILON*HE_BASE_MAG;
      omega = ((double) k -0.5)*GLACE_PI;
      p1r  = 0.0;
      p1i  = 0.0;
      p2r  = 1.0;
      p2i  = 0.0;
      q1r  = 1.0;
      q1i  = 0.0;
      q2r  = 0.0;
      q2i  = omega;
      cold = 0.0;
      cnew = 1.0; /* make sure it gets off the ground. */
      n    = 1.0;
      normfact = 1.0;
      /*
       * NB convergence wrt real part is poor, but this will be swamped by 
       *  the addition of the gamma factor.
       *    while ( abs (cold - cnew) > 10 * eps * abs(cnew) ) & (n<100)
       * Note that sometimes (especially, for example, heFactor 0.15)
       *  the coefficient is near to zero.
       */
      while (( fabs(cold - cnew) > tolval ) && (n<300.0))
        {
          cold = cnew;
          p1r = q1r + p1r * (n - HE_FACTOR_X)*normfact;
          p1i = q1i + p1i * (n - HE_FACTOR_X)*normfact;
          p2r = q2r + p2r * (n - HE_FACTOR_X)*normfact;
          p2i = q2i + p2i * (n - HE_FACTOR_X)*normfact;
          q2r = -p2i * omega + n * q2r;
          q2i =  p2r * omega + n * q2i;
          /* simulate getting exponent to normalise. */
          /*      normfact = exp(round(-0.5*log(q2r*q2r+q2i*q2i)));*/
          normfact = 1.0 /sqrt(q2r*q2r+q2i*q2i);
          q2r = q2r *normfact;
          q2i = q2i *normfact;
          q1r = (-p1i * omega + n * q1r) *normfact;
          q1i = ( p1r * omega + n * q1i) *normfact;
          cnew = (q1r*q2r+q1i*q2i) / (q2r*q2r+q2i*q2i);
          n = n + 1.0;
        }
      
      /*
       * y_cnew = incomplete_gamma(HE_FACTOR_X,i*omega)
       *
       * cnew is the required real part of an expression of y_cnew
       *    y_cnew = 1 - exp(-i*omega + HE_FACTOR_X * log(i*omega))
       *                     * cnew /gamma (HE_FACTOR_X);
       *    x = -imag((incomplete_gamma(i*omega,HE_FACTOR_X))/
       *                 (i^HE_FACTOR_X))...
       *                 *gamma(hf)/omega^HE_FACTOR_X*2^HE_FACTOR_X;
       */
      
      return (
              (1.0 - 2.0*fmod((double) k, 2.0) )  /* (-1)^k */
              * cnew + HE_GLACE_SIN_VAL*HE_GAMMA_VAL*pow(omega,-HE_FACTOR_X)
              ) * HE_TWO_POWER;
      
    } /* k!=1 */
}



/* :*** IMAGE FIELD FILTERING ***: 

 * :FUNCTION: GlaceWindTableFill (unused)
 */
void
GlaceWindTableFill(Glace_BigGray * shifted_table,
                        int row,
                        int cols,
                        Glace_Gray ** inImgHBPtrPtr,
                        Glace_BigGray * outImgPtr
)
{
   int             c;
   register Glace_BigGray *iagP;
   register Glace_Gray  *iigP;

      for (c = cols, iigP = inImgHBPtrPtr[row],
             iagP = &outImgPtr[(row+1)*cols];
           c !=0; c--,iagP++,iigP++)
         *iagP = shifted_table[*iigP];


}


/*
 * :FUNCTION: GlaceWindTableFillAll
 */
void
GlaceWindTableFillAll(
		      Glace_CfgInfo *cfgInfoPtr,
		      Glace_TableInfo *tableInfoPtr,
	      /*register Glace_BigGray * shifted_table,*/
                        int numPix,
                        Glace_Gray * hPixPtr,
                        Glace_Gray * lPixPtr,
                        Glace_BigGray * outPixPtr
)
{
   register long           c;
   register Glace_BigGray *iagP;
   register Glace_Gray  *hgP, *lgP;
  register Glace_FpSeries *thisAH, *thisAL, *thisBH, *thisBL;
   long *thisTable;

   thisTable = GLACE_TRM(seriesTable);


   if (GLACE_CFG(doublep)==GLACE_FALSE)
     for (c = numPix, hgP = hPixPtr, iagP = outPixPtr;
	  c >0;     c--, iagP++, hgP++)
       *iagP = thisTable[*hgP];
   else
     {
       thisAH = GLACE_TRM(seriesAH);
       thisAL = GLACE_TRM(seriesAL);
       thisBH = GLACE_TRM(seriesBH);
       thisBL = GLACE_TRM(seriesBL);
       for (c = numPix, hgP = hPixPtr, lgP = lPixPtr, iagP = outPixPtr;
	    c >0;     c--, iagP++, hgP++, lgP++)
	 *iagP = thisAH[*hgP]*thisAL[*lgP] +
	      thisBH[*hgP]*thisBL[*lgP] +0.5;
     }
}

/* outImgPtr is a vector (row) array of size (cols+1)*(rows+1)
   of Glace_BigGrays */

/*
 * :FUNCTION: Glace_FiltWind
 */
void 
Glace_FiltWind(
   Glace_CfgInfo *cfgInfoPtr,
   Glace_Gray * inImgHBPtr,
   Glace_Gray * inImgLBPtr, Glace_BigGray * outImgPtr,
	       /*signed long *lTable,*/
              int cols, int rows,
              Glace_TableInfo *tableInfoPtr,
              int width, int height)
{
   int             r, second_shifts, first_shifts;
   /*   Glace_BigGray            shifted_table[GLACE_MAXMAXGRAY+1];*/
   Glace_BigGray  accumX;
   Glace_BigGray *oagP;
   register Glace_BigGray accum;
   register Glace_BigGray *obgP, *iagP;
   register int c;
   long k;
 
   if ( (2*width) >= cols)
      Glace_WError( GLACE_TRM(wData),
                    "Window filter: window width too large.");
   else if ( (2*height) >= rows)
      Glace_WError( GLACE_TRM(wData),
                    "Window filter: window height too large.");
  
  /* The amount of down-shifting in preparation for the first
     pass is analogous to that for filtShifts.  However, some of
     scaling down has already been done in constructing the 
     table. */
   frexp((2*width+1.0)*((double) GLACE_TRM(filtFactor))/AFT_FILTVAL,
         &first_shifts);
   /* The shifts required before the second (vertical) pass: */
   second_shifts = GLACE_TRM(filtShifts) -first_shifts;

   Glace_FillTableForFilt (cfgInfoPtr, tableInfoPtr,
			   ldexp(1.0,-first_shifts)
			   );
/*
   for (r=0; r<=GLACE_MAXMAXGRAY; r++)
      shifted_table[r] = lTable[r] >> first_shifts;
*/
     GlaceWindTableFillAll(cfgInfoPtr,tableInfoPtr, rows*cols,
                           inImgHBPtr,inImgLBPtr, &outImgPtr[cols]);

   for (r = 0; r < rows; r++)
   {
      /* Copy row of input image using lookup table to output array,
         but starting at location (1,1). */
     /*     GlaceWindTableFill(shifted_table,r,cols,inImgHBPtrPtr,outImgPtr);*/

      /* Add up first (2*width+1) columns in each row.
         Put in zeroth column.  This is the output for the first
         width+1 columns (0 to width). */
      obgP = &outImgPtr[(r+1)*cols];

      iagP = obgP;
      accum = 0;
      for (c = (2 * width)+1; c!=0; c--, iagP++)
         accum += *iagP;
      accumX = accum;
      
      /* MAIN SCAN ACROSS */
      /* iagP is already pointing at the next one to add. */
      for (c = (cols-2*width-1); c!=0; c--, obgP++, iagP++)
      {
         /* y(k) = y(k-1) + x(k+w) - x(k-w-1) */
         accum = accum + *iagP - *obgP;
         *obgP = accum;
      }
      iagP = obgP-1;

      /* SHIFT & STORE */
      /* First the last output into the last w+1 entries. */
      accum = *iagP >> second_shifts;
      obgP = &outImgPtr[(r+1)*cols+cols-1];
      for (c=width+1; c!=0; c--, obgP--)
         *obgP = accum;
      /* Then cols-2*width-2 more */
      iagP--;
      for (c =(cols-2*width-2); c!=0; c--,iagP--,obgP--)
         *obgP = *iagP >> second_shifts;
      /* Then the first/final w+1 */
      /*      accum = *oagP >> second_shifts;*/
      accum = accumX >> second_shifts;
      for (c =width+1; c!=0; c--, obgP--)
         *obgP = accum;
   }



   /* FILTER DOWN COLUMNS */
   /* Sum first 2*height+1 rows */
   memset( outImgPtr, '\0', cols*sizeof(Glace_BigGray) );
   iagP = obgP = outImgPtr;  /* iagP only for compiler warnings */

      for (c = cols, obgP=outImgPtr;
           c!=0; c--, obgP++)
        {
          accum = 0;
          for (r=(2 * height+1), iagP=obgP+cols;
               r!=0; r--)
            {
              accum += *iagP;
              iagP+=cols;
            }
          *obgP = accum;
        }
        iagP = &outImgPtr[(2*height+2)*cols];


  /* MAIN SCAN DOWN */
  /* iagP already points to next to add, obgP to in/output. */
  /* Just do one big loop instead of nesting. */
   oagP = outImgPtr;
   for (k=(cols*(rows-2*height-1)); k!=0; k--, obgP++, oagP++, iagP++)
   {
      accum = *oagP + *iagP - *obgP;
    /* y(k) = y(k-1) + x(k+w) - x(k-w-1) */
    *obgP = accum;
    }
      
   /* STORE BY COPYING */
   /* First the last output into the last h entries. */
   for (r=height, obgP = &outImgPtr[(rows-1)*cols]; r!=0;
        r--, obgP-=cols)
      memcpy(obgP, oagP,
             cols*sizeof(Glace_BigGray));
   /* middle section */    
   memmove(&outImgPtr[height*cols], outImgPtr,
           cols*(rows-2*height)*sizeof(Glace_BigGray) );
   /* and first/final rows */
   for (r=1; r<height; r++)
      memcpy(&outImgPtr[r*cols], outImgPtr, cols*sizeof(Glace_BigGray));
}










/* outImgPtr is an image array of size (cols)*(rows+1) of Glace_MidGrays */

/*
 * :FUNCTION: Glace_FiltDD
 */
void 
Glace_FiltDD(
   Glace_CfgInfo *cfgInfoPtr,
   Glace_Gray * inImgHBPtr, Glace_MidGray * outImgPtr,
	       /*signed long *lTable,*/
              int cols, int rows,
              Glace_TableInfo *tableInfoPtr,
            Glace_Gray *hBiasArray, Glace_Gray *vBiasArray,
            int numPasses)
{
   int             r, c, k;
   Glace_Gray  *iigP;
   Glace_MidGray *iagP, *oagP;
   Glace_MidGray *ibgP;
   Glace_Gray *hwgP, *vwgP;
   Glace_BigGray accum=0;
   Glace_BigGray wgt;


   Glace_FillTableForFilt (cfgInfoPtr, tableInfoPtr, 1.0 );

   /* This may be broken */
#if 0
     GlaceWindTableFillAll(cfgInfoPtr,tableInfoPtr, rows*cols,
                           inImgHBPtr, outImgPtr);
#else
   for (r = 0; r < rows; r++)
      /* Copy row of input image using lookup table to output array. */
      for (c = 0, iigP = &inImgHBPtr[cols*r], iagP = &outImgPtr[r*cols];
           c < cols; c++,iagP++,iigP++)
         *iagP = GLACE_TRM(seriesTable)[*iigP];
#endif


   memcpy( &outImgPtr[rows*cols], &outImgPtr[(rows-1)*cols],
           cols*sizeof(Glace_MidGray)); 
  
   for (k=0; k<numPasses; k++)
   {
      if (!(k%2))
      {
         for (r = rows-2; r > 0; r--)
         {
            iagP = &outImgPtr[r*cols];
            oagP = &outImgPtr[(r+1)*cols];
            *oagP = *iagP;
            oagP++; iagP++;
            for (c = 1,
                    ibgP = &outImgPtr[(r-1)*cols]+1,
                    hwgP = &hBiasArray[cols*r], vwgP = &vBiasArray[cols*r]; 
                 c<(cols-1);
                 c++, iagP++, oagP++, ibgP++, hwgP++, vwgP++)
            { 
               /* Do everything *2048 */
               accum = ((Glace_BigGray) *iagP)<<10;
               wgt = (((Glace_BigGray) *hwgP)<<1)+1;  /* 1<= wgt <=511 */
               accum += wgt* *(iagP+1);
               accum += (512-wgt)* *(iagP-1);
               wgt = (((Glace_BigGray) *vwgP)<<1)+1;
               accum +=  *ibgP * (512-wgt);
               accum += *oagP * wgt;
               *oagP = (accum >> 11);
            }
            *oagP = *iagP;
         }
         memcpy( &outImgPtr[cols], outImgPtr, cols*sizeof(Glace_MidGray));
      } else {
         for (r = 1; r < (rows-1); r++)
         {
            iagP = &outImgPtr[(r+1)*cols];
            oagP = &outImgPtr[r*cols];
            *oagP = *iagP;
            oagP++; iagP++;
            for (c = 1, ibgP = &outImgPtr[(r+2)*cols]+1,
                    hwgP = &hBiasArray[cols*r], vwgP = &vBiasArray[cols*r]; 
                 c<(cols-1);
                 c++, iagP++, oagP++, ibgP++, hwgP++, vwgP++)
            { 
               /* Do everything *2048 */
               accum = ((Glace_BigGray) *iagP)<<10;
               
               wgt = (((Glace_BigGray) *hwgP)<<1)+1;  /* 1<= wgt <=511 */
               accum += wgt* *(iagP+1);
               accum += (512-wgt)* *(iagP-1);
               wgt = (((Glace_BigGray) *vwgP)<<1)+1;
               accum += *oagP * (512-wgt);
               accum += *ibgP * wgt;
               
               *oagP = (accum >> 11);
            }
            *oagP = *iagP;
         }
         memcpy( &outImgPtr[(rows-1)*cols],
                 &outImgPtr[rows*cols], cols*sizeof(Glace_MidGray));
      }
   }
   
/* If number of passes is odd, image is left in shifted position.*/
   if (numPasses%2)
      for (r = 0; r < rows; r++)
         memcpy(&outImgPtr[r*cols],
                &outImgPtr[(r+1)*cols], cols*sizeof(Glace_MidGray));
}
